// This IDL was generated automatically by ZAP.
// It is for view/code review purposes only.

/** Attributes and commands for putting a device into Identification mode (e.g. flashing a light). */
server cluster Identify = 3 {
  enum EffectIdentifierEnum : enum8 {
    kBlink = 0;
    kBreathe = 1;
    kOkay = 2;
    kChannelChange = 11;
    kFinishEffect = 254;
    kStopEffect = 255;
  }

  enum EffectVariantEnum : enum8 {
    kDefault = 0;
  }

  enum IdentifyTypeEnum : enum8 {
    kNone = 0;
    kLightOutput = 1;
    kVisibleIndicator = 2;
    kAudibleBeep = 3;
    kDisplay = 4;
    kActuator = 5;
  }

  attribute int16u identifyTime = 0;
  readonly attribute IdentifyTypeEnum identifyType = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct IdentifyRequest {
    int16u identifyTime = 0;
  }

  request struct TriggerEffectRequest {
    EffectIdentifierEnum effectIdentifier = 0;
    EffectVariantEnum effectVariant = 1;
  }

  command access(invoke: manage) Identify(IdentifyRequest): DefaultSuccess = 0;
  command access(invoke: manage) TriggerEffect(TriggerEffectRequest): DefaultSuccess = 64;
}

/** Attributes and commands for group configuration and manipulation. */
server cluster Groups = 4 {
  bitmap Feature : bitmap32 {
    kGroupNames = 0x1;
  }

  bitmap NameSupportBitmap : bitmap8 {
    kGroupNames = 0x80;
  }

  readonly attribute NameSupportBitmap nameSupport = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AddGroupRequest {
    group_id groupID = 0;
    char_string<16> groupName = 1;
  }

  request struct ViewGroupRequest {
    group_id groupID = 0;
  }

  request struct GetGroupMembershipRequest {
    group_id groupList[] = 0;
  }

  request struct RemoveGroupRequest {
    group_id groupID = 0;
  }

  request struct AddGroupIfIdentifyingRequest {
    group_id groupID = 0;
    char_string<16> groupName = 1;
  }

  response struct AddGroupResponse = 0 {
    enum8 status = 0;
    group_id groupID = 1;
  }

  response struct ViewGroupResponse = 1 {
    enum8 status = 0;
    group_id groupID = 1;
    char_string<16> groupName = 2;
  }

  response struct GetGroupMembershipResponse = 2 {
    nullable int8u capacity = 0;
    group_id groupList[] = 1;
  }

  response struct RemoveGroupResponse = 3 {
    enum8 status = 0;
    group_id groupID = 1;
  }

  fabric command access(invoke: manage) AddGroup(AddGroupRequest): AddGroupResponse = 0;
  fabric command ViewGroup(ViewGroupRequest): ViewGroupResponse = 1;
  fabric command GetGroupMembership(GetGroupMembershipRequest): GetGroupMembershipResponse = 2;
  fabric command access(invoke: manage) RemoveGroup(RemoveGroupRequest): RemoveGroupResponse = 3;
  fabric command access(invoke: manage) RemoveAllGroups(): DefaultSuccess = 4;
  fabric command access(invoke: manage) AddGroupIfIdentifying(AddGroupIfIdentifyingRequest): DefaultSuccess = 5;
}

/** Attributes and commands for controlling devices that can be set to a level between fully 'On' and fully 'Off.' */
client cluster LevelControl = 8 {
  enum MoveMode : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum StepMode : enum8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
    kLighting = 0x2;
    kFrequency = 0x4;
  }

  bitmap LevelControlOptions : bitmap8 {
    kExecuteIfOff = 0x1;
    kCoupleColorTempToLevel = 0x2;
  }

  readonly attribute nullable int8u currentLevel = 0;
  readonly attribute optional int16u remainingTime = 1;
  readonly attribute optional int8u minLevel = 2;
  readonly attribute optional int8u maxLevel = 3;
  readonly attribute optional int16u currentFrequency = 4;
  readonly attribute optional int16u minFrequency = 5;
  readonly attribute optional int16u maxFrequency = 6;
  attribute LevelControlOptions options = 15;
  attribute optional int16u onOffTransitionTime = 16;
  attribute nullable int8u onLevel = 17;
  attribute optional nullable int16u onTransitionTime = 18;
  attribute optional nullable int16u offTransitionTime = 19;
  attribute optional nullable int8u defaultMoveRate = 20;
  attribute access(write: manage) optional nullable int8u startUpCurrentLevel = 16384;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToLevelRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct MoveRequest {
    MoveMode moveMode = 0;
    nullable int8u rate = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct StepRequest {
    StepMode stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    LevelControlOptions optionsMask = 3;
    LevelControlOptions optionsOverride = 4;
  }

  request struct StopRequest {
    LevelControlOptions optionsMask = 0;
    LevelControlOptions optionsOverride = 1;
  }

  request struct MoveToLevelWithOnOffRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct MoveWithOnOffRequest {
    MoveMode moveMode = 0;
    nullable int8u rate = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct StepWithOnOffRequest {
    StepMode stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    LevelControlOptions optionsMask = 3;
    LevelControlOptions optionsOverride = 4;
  }

  request struct StopWithOnOffRequest {
    LevelControlOptions optionsMask = 0;
    LevelControlOptions optionsOverride = 1;
  }

  request struct MoveToClosestFrequencyRequest {
    int16u frequency = 0;
  }

  /** Command description for MoveToLevel */
  command MoveToLevel(MoveToLevelRequest): DefaultSuccess = 0;
  /** Command description for Move */
  command Move(MoveRequest): DefaultSuccess = 1;
  /** Command description for Step */
  command Step(StepRequest): DefaultSuccess = 2;
  /** Command description for Stop */
  command Stop(StopRequest): DefaultSuccess = 3;
  /** Command description for MoveToLevelWithOnOff */
  command MoveToLevelWithOnOff(MoveToLevelWithOnOffRequest): DefaultSuccess = 4;
  /** Command description for MoveWithOnOff */
  command MoveWithOnOff(MoveWithOnOffRequest): DefaultSuccess = 5;
  /** Command description for StepWithOnOff */
  command StepWithOnOff(StepWithOnOffRequest): DefaultSuccess = 6;
  /** Command description for StopWithOnOff */
  command StopWithOnOff(StopWithOnOffRequest): DefaultSuccess = 7;
  /** Change the currrent frequency to the provided one, or a close
        approximation if the exact provided one is not possible. */
  command MoveToClosestFrequency(MoveToClosestFrequencyRequest): DefaultSuccess = 8;
}

/** Attributes and commands for controlling devices that can be set to a level between fully 'On' and fully 'Off.' */
server cluster LevelControl = 8 {
  enum MoveMode : enum8 {
    kUp = 0;
    kDown = 1;
  }

  enum StepMode : enum8 {
    kUp = 0;
    kDown = 1;
  }

  bitmap Feature : bitmap32 {
    kOnOff = 0x1;
    kLighting = 0x2;
    kFrequency = 0x4;
  }

  bitmap LevelControlOptions : bitmap8 {
    kExecuteIfOff = 0x1;
    kCoupleColorTempToLevel = 0x2;
  }

  readonly attribute nullable int8u currentLevel = 0;
  attribute LevelControlOptions options = 15;
  attribute nullable int8u onLevel = 17;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct MoveToLevelRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct MoveRequest {
    MoveMode moveMode = 0;
    nullable int8u rate = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct StepRequest {
    StepMode stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    LevelControlOptions optionsMask = 3;
    LevelControlOptions optionsOverride = 4;
  }

  request struct StopRequest {
    LevelControlOptions optionsMask = 0;
    LevelControlOptions optionsOverride = 1;
  }

  request struct MoveToLevelWithOnOffRequest {
    int8u level = 0;
    nullable int16u transitionTime = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct MoveWithOnOffRequest {
    MoveMode moveMode = 0;
    nullable int8u rate = 1;
    LevelControlOptions optionsMask = 2;
    LevelControlOptions optionsOverride = 3;
  }

  request struct StepWithOnOffRequest {
    StepMode stepMode = 0;
    int8u stepSize = 1;
    nullable int16u transitionTime = 2;
    LevelControlOptions optionsMask = 3;
    LevelControlOptions optionsOverride = 4;
  }

  request struct StopWithOnOffRequest {
    LevelControlOptions optionsMask = 0;
    LevelControlOptions optionsOverride = 1;
  }

  command MoveToLevel(MoveToLevelRequest): DefaultSuccess = 0;
  command Move(MoveRequest): DefaultSuccess = 1;
  command Step(StepRequest): DefaultSuccess = 2;
  command Stop(StopRequest): DefaultSuccess = 3;
  command MoveToLevelWithOnOff(MoveToLevelWithOnOffRequest): DefaultSuccess = 4;
  command MoveWithOnOff(MoveWithOnOffRequest): DefaultSuccess = 5;
  command StepWithOnOff(StepWithOnOffRequest): DefaultSuccess = 6;
  command StopWithOnOff(StopWithOnOffRequest): DefaultSuccess = 7;
}

/** The Descriptor Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for describing a node, its endpoints and clusters. */
server cluster Descriptor = 29 {
  bitmap Feature : bitmap32 {
    kTagList = 0x1;
  }

  struct DeviceTypeStruct {
    devtype_id deviceType = 0;
    int16u revision = 1;
  }

  struct SemanticTagStruct {
    nullable vendor_id mfgCode = 0;
    enum8 namespaceID = 1;
    enum8 tag = 2;
    optional nullable char_string label = 3;
  }

  readonly attribute DeviceTypeStruct deviceTypeList[] = 0;
  readonly attribute cluster_id serverList[] = 1;
  readonly attribute cluster_id clientList[] = 2;
  readonly attribute endpoint_no partsList[] = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Binding Cluster is meant to replace the support from the Zigbee Device Object (ZDO) for supporting the binding table. */
server cluster Binding = 30 {
  fabric_scoped struct TargetStruct {
    optional node_id node = 1;
    optional group_id group = 2;
    optional endpoint_no endpoint = 3;
    optional cluster_id cluster = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(write: manage) TargetStruct binding[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The Access Control Cluster exposes a data model view of a
      Node's Access Control List (ACL), which codifies the rules used to manage
      and enforce Access Control for the Node's endpoints and their associated
      cluster instances. */
server cluster AccessControl = 31 {
  enum AccessControlEntryAuthModeEnum : enum8 {
    kPASE = 1;
    kCASE = 2;
    kGroup = 3;
  }

  enum AccessControlEntryPrivilegeEnum : enum8 {
    kView = 1;
    kProxyView = 2;
    kOperate = 3;
    kManage = 4;
    kAdminister = 5;
  }

  enum ChangeTypeEnum : enum8 {
    kChanged = 0;
    kAdded = 1;
    kRemoved = 2;
  }

  struct AccessControlTargetStruct {
    nullable cluster_id cluster = 0;
    nullable endpoint_no endpoint = 1;
    nullable devtype_id deviceType = 2;
  }

  fabric_scoped struct AccessControlEntryStruct {
    fabric_sensitive AccessControlEntryPrivilegeEnum privilege = 1;
    fabric_sensitive AccessControlEntryAuthModeEnum authMode = 2;
    nullable fabric_sensitive int64u subjects[] = 3;
    nullable fabric_sensitive AccessControlTargetStruct targets[] = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct AccessControlExtensionStruct {
    fabric_sensitive octet_string<128> data = 1;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlEntryChanged = 0 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlEntryStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  fabric_sensitive info event access(read: administer) AccessControlExtensionChanged = 1 {
    nullable node_id adminNodeID = 1;
    nullable int16u adminPasscodeID = 2;
    ChangeTypeEnum changeType = 3;
    nullable AccessControlExtensionStruct latestValue = 4;
    fabric_idx fabricIndex = 254;
  }

  attribute access(read: administer, write: administer) AccessControlEntryStruct acl[] = 0;
  attribute access(read: administer, write: administer) AccessControlExtensionStruct extension[] = 1;
  readonly attribute int16u subjectsPerAccessControlEntry = 2;
  readonly attribute int16u targetsPerAccessControlEntry = 3;
  readonly attribute int16u accessControlEntriesPerFabric = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides attributes and events for determining basic information about Nodes, which supports both
      Commissioning and operational determination of Node characteristics, such as Vendor ID, Product ID and serial number,
      which apply to the whole Node. Also allows setting user device information such as location. */
server cluster BasicInformation = 40 {
  enum ColorEnum : enum8 {
    kBlack = 0;
    kNavy = 1;
    kGreen = 2;
    kTeal = 3;
    kMaroon = 4;
    kPurple = 5;
    kOlive = 6;
    kGray = 7;
    kBlue = 8;
    kLime = 9;
    kAqua = 10;
    kRed = 11;
    kFuchsia = 12;
    kYellow = 13;
    kWhite = 14;
    kNickel = 15;
    kChrome = 16;
    kBrass = 17;
    kCopper = 18;
    kSilver = 19;
    kGold = 20;
  }

  enum ProductFinishEnum : enum8 {
    kOther = 0;
    kMatte = 1;
    kSatin = 2;
    kPolished = 3;
    kRugged = 4;
    kFabric = 5;
  }

  struct CapabilityMinimaStruct {
    int16u caseSessionsPerFabric = 0;
    int16u subscriptionsPerFabric = 1;
  }

  struct ProductAppearanceStruct {
    ProductFinishEnum finish = 0;
    nullable ColorEnum primaryColor = 1;
  }

  critical event StartUp = 0 {
    int32u softwareVersion = 0;
  }

  critical event ShutDown = 1 {
  }

  info event Leave = 2 {
    fabric_idx fabricIndex = 0;
  }

  info event ReachableChanged = 3 {
    boolean reachableNewValue = 0;
  }

  readonly attribute int16u dataModelRevision = 0;
  readonly attribute char_string<32> vendorName = 1;
  readonly attribute vendor_id vendorID = 2;
  readonly attribute char_string<32> productName = 3;
  readonly attribute int16u productID = 4;
  attribute access(write: manage) char_string<32> nodeLabel = 5;
  attribute access(write: administer) char_string<2> location = 6;
  readonly attribute int16u hardwareVersion = 7;
  readonly attribute char_string<64> hardwareVersionString = 8;
  readonly attribute int32u softwareVersion = 9;
  readonly attribute char_string<64> softwareVersionString = 10;
  readonly attribute char_string<16> manufacturingDate = 11;
  readonly attribute char_string<32> partNumber = 12;
  readonly attribute long_char_string<256> productURL = 13;
  readonly attribute char_string<64> productLabel = 14;
  readonly attribute char_string<32> serialNumber = 15;
  attribute access(write: manage) boolean localConfigDisabled = 16;
  readonly attribute boolean reachable = 17;
  readonly attribute char_string<32> uniqueID = 18;
  readonly attribute CapabilityMinimaStruct capabilityMinima = 19;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Provides an interface for providing OTA software updates */
client cluster OtaSoftwareUpdateProvider = 41 {
  enum ApplyUpdateActionEnum : enum8 {
    kProceed = 0;
    kAwaitNextAction = 1;
    kDiscontinue = 2;
  }

  enum DownloadProtocolEnum : enum8 {
    kBDXSynchronous = 0;
    kBDXAsynchronous = 1;
    kHTTPS = 2;
    kVendorSpecific = 3;
  }

  enum StatusEnum : enum8 {
    kUpdateAvailable = 0;
    kBusy = 1;
    kNotAvailable = 2;
    kDownloadProtocolNotSupported = 3;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct QueryImageRequest {
    vendor_id vendorID = 0;
    int16u productID = 1;
    int32u softwareVersion = 2;
    DownloadProtocolEnum protocolsSupported[] = 3;
    optional int16u hardwareVersion = 4;
    optional char_string<2> location = 5;
    optional boolean requestorCanConsent = 6;
    optional octet_string<512> metadataForProvider = 7;
  }

  response struct QueryImageResponse = 1 {
    StatusEnum status = 0;
    optional int32u delayedActionTime = 1;
    optional char_string<256> imageURI = 2;
    optional int32u softwareVersion = 3;
    optional char_string<64> softwareVersionString = 4;
    optional octet_string<32> updateToken = 5;
    optional boolean userConsentNeeded = 6;
    optional octet_string<512> metadataForRequestor = 7;
  }

  request struct ApplyUpdateRequestRequest {
    octet_string<32> updateToken = 0;
    int32u newVersion = 1;
  }

  response struct ApplyUpdateResponse = 3 {
    ApplyUpdateActionEnum action = 0;
    int32u delayedActionTime = 1;
  }

  request struct NotifyUpdateAppliedRequest {
    octet_string<32> updateToken = 0;
    int32u softwareVersion = 1;
  }

  /** Determine availability of a new Software Image */
  command QueryImage(QueryImageRequest): QueryImageResponse = 0;
  /** Determine next action to take for a downloaded Software Image */
  command ApplyUpdateRequest(ApplyUpdateRequestRequest): ApplyUpdateResponse = 2;
  /** Notify OTA Provider that an update was applied */
  command NotifyUpdateApplied(NotifyUpdateAppliedRequest): DefaultSuccess = 4;
}

/** Provides an interface for downloading and applying OTA software updates */
server cluster OtaSoftwareUpdateRequestor = 42 {
  enum AnnouncementReasonEnum : enum8 {
    kSimpleAnnouncement = 0;
    kUpdateAvailable = 1;
    kUrgentUpdateAvailable = 2;
  }

  enum ChangeReasonEnum : enum8 {
    kUnknown = 0;
    kSuccess = 1;
    kFailure = 2;
    kTimeOut = 3;
    kDelayByProvider = 4;
  }

  enum UpdateStateEnum : enum8 {
    kUnknown = 0;
    kIdle = 1;
    kQuerying = 2;
    kDelayedOnQuery = 3;
    kDownloading = 4;
    kApplying = 5;
    kDelayedOnApply = 6;
    kRollingBack = 7;
    kDelayedOnUserConsent = 8;
  }

  fabric_scoped struct ProviderLocation {
    node_id providerNodeID = 1;
    endpoint_no endpoint = 2;
    fabric_idx fabricIndex = 254;
  }

  info event StateTransition = 0 {
    UpdateStateEnum previousState = 0;
    UpdateStateEnum newState = 1;
    ChangeReasonEnum reason = 2;
    nullable int32u targetSoftwareVersion = 3;
  }

  critical event VersionApplied = 1 {
    int32u softwareVersion = 0;
    int16u productID = 1;
  }

  info event DownloadError = 2 {
    int32u softwareVersion = 0;
    int64u bytesDownloaded = 1;
    nullable int8u progressPercent = 2;
    nullable int64s platformCode = 3;
  }

  attribute ProviderLocation defaultOTAProviders[] = 0;
  readonly attribute boolean updatePossible = 1;
  readonly attribute UpdateStateEnum updateState = 2;
  readonly attribute nullable int8u updateStateProgress = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AnnounceOTAProviderRequest {
    node_id providerNodeID = 0;
    vendor_id vendorID = 1;
    AnnouncementReasonEnum announcementReason = 2;
    optional octet_string<512> metadataForNode = 3;
    endpoint_no endpoint = 4;
  }

  command AnnounceOTAProvider(AnnounceOTAProviderRequest): DefaultSuccess = 0;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing common languages, units of measurements, and numerical formatting
      standards. As such, Nodes that visually or audibly convey information need a mechanism by which
      they can be configured to use a user’s preferred language, units, etc */
server cluster LocalizationConfiguration = 43 {
  attribute access(write: manage) char_string<35> activeLocale = 0;
  readonly attribute char_string supportedLocales[] = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Nodes should be expected to be deployed to any and all regions of the world. These global regions
      may have differing preferences for how dates and times are conveyed. As such, Nodes that visually
      or audibly convey time information need a mechanism by which they can be configured to use a
      user’s preferred format. */
server cluster TimeFormatLocalization = 44 {
  enum CalendarTypeEnum : enum8 {
    kBuddhist = 0;
    kChinese = 1;
    kCoptic = 2;
    kEthiopian = 3;
    kGregorian = 4;
    kHebrew = 5;
    kIndian = 6;
    kIslamic = 7;
    kJapanese = 8;
    kKorean = 9;
    kPersian = 10;
    kTaiwanese = 11;
  }

  enum HourFormatEnum : enum8 {
    k12hr = 0;
    k24hr = 1;
  }

  bitmap Feature : bitmap32 {
    kCalendarFormat = 0x1;
  }

  attribute access(write: manage) HourFormatEnum hourFormat = 0;
  attribute access(write: manage) CalendarTypeEnum activeCalendarType = 1;
  readonly attribute CalendarTypeEnum supportedCalendarTypes[] = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster is used to manage global aspects of the Commissioning flow. */
server cluster GeneralCommissioning = 48 {
  enum CommissioningErrorEnum : enum8 {
    kOK = 0;
    kValueOutsideRange = 1;
    kInvalidAuthentication = 2;
    kNoFailSafe = 3;
    kBusyWithOtherAdmin = 4;
  }

  enum RegulatoryLocationTypeEnum : enum8 {
    kIndoor = 0;
    kOutdoor = 1;
    kIndoorOutdoor = 2;
  }

  struct BasicCommissioningInfo {
    int16u failSafeExpiryLengthSeconds = 0;
    int16u maxCumulativeFailsafeSeconds = 1;
  }

  attribute access(write: administer) int64u breadcrumb = 0;
  readonly attribute BasicCommissioningInfo basicCommissioningInfo = 1;
  readonly attribute RegulatoryLocationTypeEnum regulatoryConfig = 2;
  readonly attribute RegulatoryLocationTypeEnum locationCapability = 3;
  readonly attribute boolean supportsConcurrentConnection = 4;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ArmFailSafeRequest {
    int16u expiryLengthSeconds = 0;
    int64u breadcrumb = 1;
  }

  request struct SetRegulatoryConfigRequest {
    RegulatoryLocationTypeEnum newRegulatoryConfig = 0;
    char_string countryCode = 1;
    int64u breadcrumb = 2;
  }

  response struct ArmFailSafeResponse = 1 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  response struct SetRegulatoryConfigResponse = 3 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  response struct CommissioningCompleteResponse = 5 {
    CommissioningErrorEnum errorCode = 0;
    char_string debugText = 1;
  }

  command access(invoke: administer) ArmFailSafe(ArmFailSafeRequest): ArmFailSafeResponse = 0;
  command access(invoke: administer) SetRegulatoryConfig(SetRegulatoryConfigRequest): SetRegulatoryConfigResponse = 2;
  fabric command access(invoke: administer) CommissioningComplete(): CommissioningCompleteResponse = 4;
}

/** Functionality to configure, enable, disable network credentials and access on a Matter device. */
server cluster NetworkCommissioning = 49 {
  enum NetworkCommissioningStatusEnum : enum8 {
    kSuccess = 0;
    kOutOfRange = 1;
    kBoundsExceeded = 2;
    kNetworkIDNotFound = 3;
    kDuplicateNetworkID = 4;
    kNetworkNotFound = 5;
    kRegulatoryError = 6;
    kAuthFailure = 7;
    kUnsupportedSecurity = 8;
    kOtherConnectionFailure = 9;
    kIPV6Failed = 10;
    kIPBindFailed = 11;
    kUnknownError = 12;
  }

  enum WiFiBandEnum : enum8 {
    k2G4 = 0;
    k3G65 = 1;
    k5G = 2;
    k6G = 3;
    k60G = 4;
    k1G = 5;
  }

  bitmap Feature : bitmap32 {
    kWiFiNetworkInterface = 0x1;
    kThreadNetworkInterface = 0x2;
    kEthernetNetworkInterface = 0x4;
  }

  bitmap ThreadCapabilitiesBitmap : bitmap16 {
    kIsBorderRouterCapable = 0x1;
    kIsRouterCapable = 0x2;
    kIsSleepyEndDeviceCapable = 0x4;
    kIsFullThreadDevice = 0x8;
    kIsSynchronizedSleepyEndDeviceCapable = 0x10;
  }

  bitmap WiFiSecurityBitmap : bitmap8 {
    kUnencrypted = 0x1;
    kWEP = 0x2;
    kWPAPersonal = 0x4;
    kWPA2Personal = 0x8;
    kWPA3Personal = 0x10;
  }

  struct NetworkInfoStruct {
    octet_string<32> networkID = 0;
    boolean connected = 1;
  }

  struct ThreadInterfaceScanResultStruct {
    int16u panId = 0;
    int64u extendedPanId = 1;
    char_string<16> networkName = 2;
    int16u channel = 3;
    int8u version = 4;
    octet_string<8> extendedAddress = 5;
    int8s rssi = 6;
    int8u lqi = 7;
  }

  struct WiFiInterfaceScanResultStruct {
    WiFiSecurityBitmap security = 0;
    octet_string<32> ssid = 1;
    octet_string<6> bssid = 2;
    int16u channel = 3;
    WiFiBandEnum wiFiBand = 4;
    int8s rssi = 5;
  }

  readonly attribute access(read: administer) int8u maxNetworks = 0;
  readonly attribute access(read: administer) NetworkInfoStruct networks[] = 1;
  readonly attribute int8u scanMaxTimeSeconds = 2;
  readonly attribute int8u connectMaxTimeSeconds = 3;
  attribute access(write: administer) boolean interfaceEnabled = 4;
  readonly attribute access(read: administer) nullable NetworkCommissioningStatusEnum lastNetworkingStatus = 5;
  readonly attribute access(read: administer) nullable octet_string<32> lastNetworkID = 6;
  readonly attribute access(read: administer) nullable int32s lastConnectErrorValue = 7;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct ScanNetworksRequest {
    optional nullable octet_string<32> ssid = 0;
    optional int64u breadcrumb = 1;
  }

  request struct AddOrUpdateWiFiNetworkRequest {
    octet_string<32> ssid = 0;
    octet_string<64> credentials = 1;
    optional int64u breadcrumb = 2;
  }

  request struct AddOrUpdateThreadNetworkRequest {
    octet_string<254> operationalDataset = 0;
    optional int64u breadcrumb = 1;
  }

  request struct RemoveNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  request struct ConnectNetworkRequest {
    octet_string<32> networkID = 0;
    optional int64u breadcrumb = 1;
  }

  request struct ReorderNetworkRequest {
    octet_string<32> networkID = 0;
    int8u networkIndex = 1;
    optional int64u breadcrumb = 2;
  }

  response struct ScanNetworksResponse = 1 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    optional WiFiInterfaceScanResultStruct wiFiScanResults[] = 2;
    optional ThreadInterfaceScanResultStruct threadScanResults[] = 3;
  }

  response struct NetworkConfigResponse = 5 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string<512> debugText = 1;
    optional int8u networkIndex = 2;
  }

  response struct ConnectNetworkResponse = 7 {
    NetworkCommissioningStatusEnum networkingStatus = 0;
    optional char_string debugText = 1;
    nullable int32s errorValue = 2;
  }

  command access(invoke: administer) ScanNetworks(ScanNetworksRequest): ScanNetworksResponse = 0;
  command access(invoke: administer) AddOrUpdateWiFiNetwork(AddOrUpdateWiFiNetworkRequest): NetworkConfigResponse = 2;
  command access(invoke: administer) AddOrUpdateThreadNetwork(AddOrUpdateThreadNetworkRequest): NetworkConfigResponse = 3;
  command access(invoke: administer) RemoveNetwork(RemoveNetworkRequest): NetworkConfigResponse = 4;
  command access(invoke: administer) ConnectNetwork(ConnectNetworkRequest): ConnectNetworkResponse = 6;
  command access(invoke: administer) ReorderNetwork(ReorderNetworkRequest): NetworkConfigResponse = 8;
}

/** The cluster provides commands for retrieving unstructured diagnostic logs from a Node that may be used to aid in diagnostics. */
server cluster DiagnosticLogs = 50 {
  enum IntentEnum : enum8 {
    kEndUserSupport = 0;
    kNetworkDiag = 1;
    kCrashLogs = 2;
  }

  enum StatusEnum : enum8 {
    kSuccess = 0;
    kExhausted = 1;
    kNoLogs = 2;
    kBusy = 3;
    kDenied = 4;
  }

  enum TransferProtocolEnum : enum8 {
    kResponsePayload = 0;
    kBDX = 1;
  }

  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct RetrieveLogsRequestRequest {
    IntentEnum intent = 0;
    TransferProtocolEnum requestedProtocol = 1;
    optional char_string<32> transferFileDesignator = 2;
  }

  command RetrieveLogsRequest(RetrieveLogsRequestRequest): RetrieveLogsResponse = 0;
}

/** The General Diagnostics Cluster, along with other diagnostics clusters, provide a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
server cluster GeneralDiagnostics = 51 {
  enum BootReasonEnum : enum8 {
    kUnspecified = 0;
    kPowerOnReboot = 1;
    kBrownOutReset = 2;
    kSoftwareWatchdogReset = 3;
    kHardwareWatchdogReset = 4;
    kSoftwareUpdateCompleted = 5;
    kSoftwareReset = 6;
  }

  enum HardwareFaultEnum : enum8 {
    kUnspecified = 0;
    kRadio = 1;
    kSensor = 2;
    kResettableOverTemp = 3;
    kNonResettableOverTemp = 4;
    kPowerSource = 5;
    kVisualDisplayFault = 6;
    kAudioOutputFault = 7;
    kUserInterfaceFault = 8;
    kNonVolatileMemoryError = 9;
    kTamperDetected = 10;
  }

  enum InterfaceTypeEnum : enum8 {
    kUnspecified = 0;
    kWiFi = 1;
    kEthernet = 2;
    kCellular = 3;
    kThread = 4;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kHardwareFailure = 1;
    kNetworkJammed = 2;
    kConnectionFailed = 3;
  }

  enum RadioFaultEnum : enum8 {
    kUnspecified = 0;
    kWiFiFault = 1;
    kCellularFault = 2;
    kThreadFault = 3;
    kNFCFault = 4;
    kBLEFault = 5;
    kEthernetFault = 6;
  }

  struct NetworkInterface {
    char_string<32> name = 0;
    boolean isOperational = 1;
    nullable boolean offPremiseServicesReachableIPv4 = 2;
    nullable boolean offPremiseServicesReachableIPv6 = 3;
    octet_string<8> hardwareAddress = 4;
    octet_string IPv4Addresses[] = 5;
    octet_string IPv6Addresses[] = 6;
    InterfaceTypeEnum type = 7;
  }

  critical event HardwareFaultChange = 0 {
    HardwareFaultEnum current[] = 0;
    HardwareFaultEnum previous[] = 1;
  }

  critical event RadioFaultChange = 1 {
    RadioFaultEnum current[] = 0;
    RadioFaultEnum previous[] = 1;
  }

  critical event NetworkFaultChange = 2 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  critical event BootReason = 3 {
    BootReasonEnum bootReason = 0;
  }

  readonly attribute NetworkInterface networkInterfaces[] = 0;
  readonly attribute int16u rebootCount = 1;
  readonly attribute int64u upTime = 2;
  readonly attribute int32u totalOperationalHours = 3;
  readonly attribute BootReasonEnum bootReason = 4;
  readonly attribute HardwareFaultEnum activeHardwareFaults[] = 5;
  readonly attribute RadioFaultEnum activeRadioFaults[] = 6;
  readonly attribute NetworkFaultEnum activeNetworkFaults[] = 7;
  readonly attribute boolean testEventTriggersEnabled = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct TestEventTriggerRequest {
    octet_string<16> enableKey = 0;
    int64u eventTrigger = 1;
  }

  command access(invoke: manage) TestEventTrigger(TestEventTriggerRequest): DefaultSuccess = 0;
}

/** The Software Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
server cluster SoftwareDiagnostics = 52 {
  bitmap Feature : bitmap32 {
    kWatermarks = 0x1;
  }

  struct ThreadMetricsStruct {
    int64u id = 0;
    optional char_string<8> name = 1;
    optional int32u stackFreeCurrent = 2;
    optional int32u stackFreeMinimum = 3;
    optional int32u stackSize = 4;
  }

  info event SoftwareFault = 0 {
    int64u id = 0;
    optional char_string name = 1;
    optional octet_string faultRecording = 2;
  }

  readonly attribute ThreadMetricsStruct threadMetrics[] = 0;
  readonly attribute int64u currentHeapFree = 1;
  readonly attribute int64u currentHeapUsed = 2;
  readonly attribute int64u currentHeapHighWatermark = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command access(invoke: manage) ResetWatermarks(): DefaultSuccess = 0;
}

/** The Thread Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems */
server cluster ThreadNetworkDiagnostics = 53 {
  enum ConnectionStatusEnum : enum8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum NetworkFaultEnum : enum8 {
    kUnspecified = 0;
    kLinkDown = 1;
    kHardwareFailure = 2;
    kNetworkJammed = 3;
  }

  enum RoutingRoleEnum : enum8 {
    kUnspecified = 0;
    kUnassigned = 1;
    kSleepyEndDevice = 2;
    kEndDevice = 3;
    kREED = 4;
    kRouter = 5;
    kLeader = 6;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
    kMLECounts = 0x4;
    kMACCounts = 0x8;
  }

  struct NeighborTableStruct {
    int64u extAddress = 0;
    int32u age = 1;
    int16u rloc16 = 2;
    int32u linkFrameCounter = 3;
    int32u mleFrameCounter = 4;
    int8u lqi = 5;
    nullable int8s averageRssi = 6;
    nullable int8s lastRssi = 7;
    int8u frameErrorRate = 8;
    int8u messageErrorRate = 9;
    boolean rxOnWhenIdle = 10;
    boolean fullThreadDevice = 11;
    boolean fullNetworkData = 12;
    boolean isChild = 13;
  }

  struct OperationalDatasetComponents {
    boolean activeTimestampPresent = 0;
    boolean pendingTimestampPresent = 1;
    boolean masterKeyPresent = 2;
    boolean networkNamePresent = 3;
    boolean extendedPanIdPresent = 4;
    boolean meshLocalPrefixPresent = 5;
    boolean delayPresent = 6;
    boolean panIdPresent = 7;
    boolean channelPresent = 8;
    boolean pskcPresent = 9;
    boolean securityPolicyPresent = 10;
    boolean channelMaskPresent = 11;
  }

  struct RouteTableStruct {
    int64u extAddress = 0;
    int16u rloc16 = 1;
    int8u routerId = 2;
    int8u nextHop = 3;
    int8u pathCost = 4;
    int8u LQIIn = 5;
    int8u LQIOut = 6;
    int8u age = 7;
    boolean allocated = 8;
    boolean linkEstablished = 9;
  }

  struct SecurityPolicy {
    int16u rotationTime = 0;
    int16u flags = 1;
  }

  info event ConnectionStatus = 0 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  info event NetworkFaultChange = 1 {
    NetworkFaultEnum current[] = 0;
    NetworkFaultEnum previous[] = 1;
  }

  readonly attribute nullable int16u channel = 0;
  readonly attribute nullable RoutingRoleEnum routingRole = 1;
  readonly attribute nullable char_string<16> networkName = 2;
  readonly attribute nullable int16u panId = 3;
  readonly attribute nullable int64u extendedPanId = 4;
  readonly attribute nullable octet_string<17> meshLocalPrefix = 5;
  readonly attribute int64u overrunCount = 6;
  readonly attribute NeighborTableStruct neighborTable[] = 7;
  readonly attribute RouteTableStruct routeTable[] = 8;
  readonly attribute nullable int32u partitionId = 9;
  readonly attribute nullable int16u weighting = 10;
  readonly attribute nullable int16u dataVersion = 11;
  readonly attribute nullable int16u stableDataVersion = 12;
  readonly attribute nullable int8u leaderRouterId = 13;
  readonly attribute int16u detachedRoleCount = 14;
  readonly attribute int16u childRoleCount = 15;
  readonly attribute int16u routerRoleCount = 16;
  readonly attribute int16u leaderRoleCount = 17;
  readonly attribute int16u attachAttemptCount = 18;
  readonly attribute int16u partitionIdChangeCount = 19;
  readonly attribute int16u betterPartitionAttachAttemptCount = 20;
  readonly attribute int16u parentChangeCount = 21;
  readonly attribute int32u txTotalCount = 22;
  readonly attribute int32u txUnicastCount = 23;
  readonly attribute int32u txBroadcastCount = 24;
  readonly attribute int32u txAckRequestedCount = 25;
  readonly attribute int32u txAckedCount = 26;
  readonly attribute int32u txNoAckRequestedCount = 27;
  readonly attribute int32u txDataCount = 28;
  readonly attribute int32u txDataPollCount = 29;
  readonly attribute int32u txBeaconCount = 30;
  readonly attribute int32u txBeaconRequestCount = 31;
  readonly attribute int32u txOtherCount = 32;
  readonly attribute int32u txRetryCount = 33;
  readonly attribute int32u txDirectMaxRetryExpiryCount = 34;
  readonly attribute int32u txIndirectMaxRetryExpiryCount = 35;
  readonly attribute int32u txErrCcaCount = 36;
  readonly attribute int32u txErrAbortCount = 37;
  readonly attribute int32u txErrBusyChannelCount = 38;
  readonly attribute int32u rxTotalCount = 39;
  readonly attribute int32u rxUnicastCount = 40;
  readonly attribute int32u rxBroadcastCount = 41;
  readonly attribute int32u rxDataCount = 42;
  readonly attribute int32u rxDataPollCount = 43;
  readonly attribute int32u rxBeaconCount = 44;
  readonly attribute int32u rxBeaconRequestCount = 45;
  readonly attribute int32u rxOtherCount = 46;
  readonly attribute int32u rxAddressFilteredCount = 47;
  readonly attribute int32u rxDestAddrFilteredCount = 48;
  readonly attribute int32u rxDuplicatedCount = 49;
  readonly attribute int32u rxErrNoFrameCount = 50;
  readonly attribute int32u rxErrUnknownNeighborCount = 51;
  readonly attribute int32u rxErrInvalidSrcAddrCount = 52;
  readonly attribute int32u rxErrSecCount = 53;
  readonly attribute int32u rxErrFcsCount = 54;
  readonly attribute int32u rxErrOtherCount = 55;
  readonly attribute nullable int64u activeTimestamp = 56;
  readonly attribute nullable int64u pendingTimestamp = 57;
  readonly attribute nullable int32u delay = 58;
  readonly attribute nullable SecurityPolicy securityPolicy = 59;
  readonly attribute nullable octet_string<4> channelPage0Mask = 60;
  readonly attribute nullable OperationalDatasetComponents operationalDatasetComponents = 61;
  readonly attribute NetworkFaultEnum activeNetworkFaultsList[] = 62;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command access(invoke: manage) ResetCounts(): DefaultSuccess = 0;
}

/** The Wi-Fi Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
server cluster WiFiNetworkDiagnostics = 54 {
  enum AssociationFailureCauseEnum : enum8 {
    kUnknown = 0;
    kAssociationFailed = 1;
    kAuthenticationFailed = 2;
    kSsidNotFound = 3;
  }

  enum ConnectionStatusEnum : enum8 {
    kConnected = 0;
    kNotConnected = 1;
  }

  enum SecurityTypeEnum : enum8 {
    kUnspecified = 0;
    kNone = 1;
    kWEP = 2;
    kWPA = 3;
    kWPA2 = 4;
    kWPA3 = 5;
  }

  enum WiFiVersionEnum : enum8 {
    kA = 0;
    kB = 1;
    kG = 2;
    kN = 3;
    kAc = 4;
    kAx = 5;
    kAh = 6;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  info event Disconnection = 0 {
    int16u reasonCode = 0;
  }

  info event AssociationFailure = 1 {
    AssociationFailureCauseEnum associationFailureCause = 0;
    int16u status = 1;
  }

  info event ConnectionStatus = 2 {
    ConnectionStatusEnum connectionStatus = 0;
  }

  readonly attribute nullable octet_string<6> bssid = 0;
  readonly attribute nullable SecurityTypeEnum securityType = 1;
  readonly attribute nullable WiFiVersionEnum wiFiVersion = 2;
  readonly attribute nullable int16u channelNumber = 3;
  readonly attribute nullable int8s rssi = 4;
  readonly attribute nullable int32u beaconLostCount = 5;
  readonly attribute nullable int32u beaconRxCount = 6;
  readonly attribute nullable int32u packetMulticastRxCount = 7;
  readonly attribute nullable int32u packetMulticastTxCount = 8;
  readonly attribute nullable int32u packetUnicastRxCount = 9;
  readonly attribute nullable int32u packetUnicastTxCount = 10;
  readonly attribute nullable int64u currentMaxRate = 11;
  readonly attribute nullable int64u overrunCount = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command ResetCounts(): DefaultSuccess = 0;
}

/** The Ethernet Network Diagnostics Cluster provides a means to acquire standardized diagnostics metrics that MAY be used by a Node to assist a user or Administrative Node in diagnosing potential problems. */
server cluster EthernetNetworkDiagnostics = 55 {
  enum PHYRateEnum : enum8 {
    kRate10M = 0;
    kRate100M = 1;
    kRate1G = 2;
    kRate25G = 3;
    kRate5G = 4;
    kRate10G = 5;
    kRate40G = 6;
    kRate100G = 7;
    kRate200G = 8;
    kRate400G = 9;
  }

  bitmap Feature : bitmap32 {
    kPacketCounts = 0x1;
    kErrorCounts = 0x2;
  }

  readonly attribute nullable PHYRateEnum PHYRate = 0;
  readonly attribute nullable boolean fullDuplex = 1;
  readonly attribute int64u packetRxCount = 2;
  readonly attribute int64u packetTxCount = 3;
  readonly attribute int64u txErrCount = 4;
  readonly attribute int64u collisionCount = 5;
  readonly attribute int64u overrunCount = 6;
  readonly attribute nullable boolean carrierDetect = 7;
  readonly attribute int64u timeSinceReset = 8;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  command access(invoke: manage) ResetCounts(): DefaultSuccess = 0;
}

/** This cluster exposes interactions with a switch device, for the purpose of using those interactions by other devices.
Two types of switch devices are supported: latching switch (e.g. rocker switch) and momentary switch (e.g. push button), distinguished with their feature flags.
Interactions with the switch device are exposed as attributes (for the latching switch) and as events (for both types of switches). An interested party MAY subscribe to these attributes/events and thus be informed of the interactions, and can perform actions based on this, for example by sending commands to perform an action such as controlling a light or a window shade. */
server cluster Switch = 59 {
  bitmap Feature : bitmap32 {
    kLatchingSwitch = 0x1;
    kMomentarySwitch = 0x2;
    kMomentarySwitchRelease = 0x4;
    kMomentarySwitchLongPress = 0x8;
    kMomentarySwitchMultiPress = 0x10;
  }

  info event SwitchLatched = 0 {
    int8u newPosition = 0;
  }

  info event InitialPress = 1 {
    int8u newPosition = 0;
  }

  info event LongPress = 2 {
    int8u newPosition = 0;
  }

  info event ShortRelease = 3 {
    int8u previousPosition = 0;
  }

  info event LongRelease = 4 {
    int8u previousPosition = 0;
  }

  info event MultiPressOngoing = 5 {
    int8u newPosition = 0;
    int8u currentNumberOfPressesCounted = 1;
  }

  info event MultiPressComplete = 6 {
    int8u previousPosition = 0;
    int8u totalNumberOfPressesCounted = 1;
  }

  readonly attribute int8u numberOfPositions = 0;
  readonly attribute int8u currentPosition = 1;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Commands to trigger a Node to allow a new Administrator to commission it. */
server cluster AdministratorCommissioning = 60 {
  enum CommissioningWindowStatusEnum : enum8 {
    kWindowNotOpen = 0;
    kEnhancedWindowOpen = 1;
    kBasicWindowOpen = 2;
  }

  enum StatusCode : enum8 {
    kBusy = 2;
    kPAKEParameterError = 3;
    kWindowNotOpen = 4;
  }

  bitmap Feature : bitmap32 {
    kBasic = 0x1;
  }

  readonly attribute CommissioningWindowStatusEnum windowStatus = 0;
  readonly attribute nullable fabric_idx adminFabricIndex = 1;
  readonly attribute nullable vendor_id adminVendorId = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct OpenCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
    octet_string PAKEPasscodeVerifier = 1;
    int16u discriminator = 2;
    int32u iterations = 3;
    octet_string<32> salt = 4;
  }

  request struct OpenBasicCommissioningWindowRequest {
    int16u commissioningTimeout = 0;
  }

  timed command access(invoke: administer) OpenCommissioningWindow(OpenCommissioningWindowRequest): DefaultSuccess = 0;
  timed command access(invoke: administer) OpenBasicCommissioningWindow(OpenBasicCommissioningWindowRequest): DefaultSuccess = 1;
  timed command access(invoke: administer) RevokeCommissioning(): DefaultSuccess = 2;
}

/** This cluster is used to add or remove Operational Credentials on a Commissionee or Node, as well as manage the associated Fabrics. */
server cluster OperationalCredentials = 62 {
  enum CertificateChainTypeEnum : enum8 {
    kDACCertificate = 1;
    kPAICertificate = 2;
  }

  enum NodeOperationalCertStatusEnum : enum8 {
    kOK = 0;
    kInvalidPublicKey = 1;
    kInvalidNodeOpId = 2;
    kInvalidNOC = 3;
    kMissingCsr = 4;
    kTableFull = 5;
    kInvalidAdminSubject = 6;
    kFabricConflict = 9;
    kLabelConflict = 10;
    kInvalidFabricIndex = 11;
  }

  fabric_scoped struct FabricDescriptorStruct {
    octet_string<65> rootPublicKey = 1;
    vendor_id vendorID = 2;
    fabric_id fabricID = 3;
    node_id nodeID = 4;
    char_string<32> label = 5;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct NOCStruct {
    fabric_sensitive octet_string noc = 1;
    nullable fabric_sensitive octet_string icac = 2;
    fabric_idx fabricIndex = 254;
  }

  readonly attribute access(read: administer) NOCStruct NOCs[] = 0;
  readonly attribute FabricDescriptorStruct fabrics[] = 1;
  readonly attribute int8u supportedFabrics = 2;
  readonly attribute int8u commissionedFabrics = 3;
  readonly attribute octet_string trustedRootCertificates[] = 4;
  readonly attribute int8u currentFabricIndex = 5;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct AttestationRequestRequest {
    octet_string<32> attestationNonce = 0;
  }

  request struct CertificateChainRequestRequest {
    CertificateChainTypeEnum certificateType = 0;
  }

  request struct CSRRequestRequest {
    octet_string<32> CSRNonce = 0;
    optional boolean isForUpdateNOC = 1;
  }

  request struct AddNOCRequest {
    octet_string<400> NOCValue = 0;
    optional octet_string<400> ICACValue = 1;
    octet_string<16> IPKValue = 2;
    int64u caseAdminSubject = 3;
    vendor_id adminVendorId = 4;
  }

  request struct UpdateNOCRequest {
    octet_string NOCValue = 0;
    optional octet_string ICACValue = 1;
  }

  request struct UpdateFabricLabelRequest {
    char_string<32> label = 0;
  }

  request struct RemoveFabricRequest {
    fabric_idx fabricIndex = 0;
  }

  request struct AddTrustedRootCertificateRequest {
    octet_string rootCACertificate = 0;
  }

  response struct AttestationResponse = 1 {
    octet_string<900> attestationElements = 0;
    octet_string<64> attestationSignature = 1;
  }

  response struct CertificateChainResponse = 3 {
    octet_string<600> certificate = 0;
  }

  response struct CSRResponse = 5 {
    octet_string NOCSRElements = 0;
    octet_string attestationSignature = 1;
  }

  response struct NOCResponse = 8 {
    NodeOperationalCertStatusEnum statusCode = 0;
    optional fabric_idx fabricIndex = 1;
    optional char_string<128> debugText = 2;
  }

  command access(invoke: administer) AttestationRequest(AttestationRequestRequest): AttestationResponse = 0;
  command access(invoke: administer) CertificateChainRequest(CertificateChainRequestRequest): CertificateChainResponse = 2;
  command access(invoke: administer) CSRRequest(CSRRequestRequest): CSRResponse = 4;
  command access(invoke: administer) AddNOC(AddNOCRequest): NOCResponse = 6;
  fabric command access(invoke: administer) UpdateNOC(UpdateNOCRequest): NOCResponse = 7;
  fabric command access(invoke: administer) UpdateFabricLabel(UpdateFabricLabelRequest): NOCResponse = 9;
  command access(invoke: administer) RemoveFabric(RemoveFabricRequest): NOCResponse = 10;
  command access(invoke: administer) AddTrustedRootCertificate(AddTrustedRootCertificateRequest): DefaultSuccess = 11;
}

/** The Group Key Management Cluster is the mechanism by which group keys are managed. */
server cluster GroupKeyManagement = 63 {
  enum GroupKeySecurityPolicyEnum : enum8 {
    kTrustFirst = 0;
    kCacheAndSync = 1;
  }

  bitmap Feature : bitmap32 {
    kCacheAndSync = 0x1;
  }

  fabric_scoped struct GroupInfoMapStruct {
    group_id groupId = 1;
    endpoint_no endpoints[] = 2;
    optional char_string<16> groupName = 3;
    fabric_idx fabricIndex = 254;
  }

  fabric_scoped struct GroupKeyMapStruct {
    group_id groupId = 1;
    int16u groupKeySetID = 2;
    fabric_idx fabricIndex = 254;
  }

  struct GroupKeySetStruct {
    int16u groupKeySetID = 0;
    GroupKeySecurityPolicyEnum groupKeySecurityPolicy = 1;
    nullable octet_string<16> epochKey0 = 2;
    nullable epoch_us epochStartTime0 = 3;
    nullable octet_string<16> epochKey1 = 4;
    nullable epoch_us epochStartTime1 = 5;
    nullable octet_string<16> epochKey2 = 6;
    nullable epoch_us epochStartTime2 = 7;
  }

  attribute access(write: manage) GroupKeyMapStruct groupKeyMap[] = 0;
  readonly attribute GroupInfoMapStruct groupTable[] = 1;
  readonly attribute int16u maxGroupsPerFabric = 2;
  readonly attribute int16u maxGroupKeysPerFabric = 3;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct KeySetWriteRequest {
    GroupKeySetStruct groupKeySet = 0;
  }

  request struct KeySetReadRequest {
    int16u groupKeySetID = 0;
  }

  request struct KeySetRemoveRequest {
    int16u groupKeySetID = 0;
  }

  response struct KeySetReadResponse = 2 {
    GroupKeySetStruct groupKeySet = 0;
  }

  response struct KeySetReadAllIndicesResponse = 5 {
    int16u groupKeySetIDs[] = 0;
  }

  fabric command access(invoke: administer) KeySetWrite(KeySetWriteRequest): DefaultSuccess = 0;
  fabric command access(invoke: administer) KeySetRead(KeySetReadRequest): KeySetReadResponse = 1;
  fabric command access(invoke: administer) KeySetRemove(KeySetRemoveRequest): DefaultSuccess = 3;
  fabric command access(invoke: administer) KeySetReadAllIndices(): KeySetReadAllIndicesResponse = 4;
}

/** The Fixed Label Cluster provides a feature for the device to tag an endpoint with zero or more read only
labels. */
server cluster FixedLabel = 64 {
  struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  readonly attribute LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** The User Label Cluster provides a feature to tag an endpoint with zero or more labels. */
server cluster UserLabel = 65 {
  struct LabelStruct {
    char_string<16> label = 0;
    char_string<16> value = 1;
  }

  attribute access(write: manage) LabelStruct labelList[] = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster allows a client to manage the energy usage of a device. An example of such a client could be an Energy Management System (EMS) which controls an Energy Smart Appliance (ESA). */
server cluster DeviceEnergyManagement = 152 {
  enum CauseEnum : enum8 {
    kNormalCompletion = 0;
    kOffline = 1;
    kFault = 2;
    kUserOptout = 3;
  }

  enum CostTypeEnum : enum8 {
    kFinancial = 0;
    kGHGEmissions = 1;
    kComfort = 2;
    kTemperature = 3;
  }

  enum EsaStateEnum : enum8 {
    kOffline = 0;
    kOnline = 1;
    kFault = 2;
    kUserOptOut = 3;
    kPowerAdjustActive = 4;
    kPaused = 5;
  }

  enum EsaTypeEnum : enum8 {
    kEVSE = 0;
    kSpaceHeating = 1;
    kWaterHeating = 2;
    kSpaceCooling = 3;
    kSpaceHeatingCooling = 4;
    kBatteryStorage = 5;
    kSolarPV = 6;
    kFridgeFreezer = 7;
    kWashingMachine = 8;
    kDishwasher = 9;
    kCooking = 10;
    kOther = 255;
  }

  bitmap Feature : bitmap32 {
    kPowerAdjustment = 0x1;
    kPowerForecastReporting = 0x2;
    kStateForecastReporting = 0x4;
    kForecastAdjustment = 0x8;
  }

  struct CostStruct {
    CostTypeEnum costType = 0;
    int32s value = 1;
    int8u decimalPoints = 2;
    optional int16u currency = 3;
  }

  struct SlotStruct {
    elapsed_s minDuration = 0;
    elapsed_s maxDuration = 1;
    elapsed_s defaultDuration = 2;
    elapsed_s elapsedSlotTime = 3;
    elapsed_s remainingSlotTime = 4;
    optional boolean slotIsPauseable = 5;
    optional int16u manufacturerESAState = 6;
    optional int32s nominalPower = 7;
    optional int32s minPower = 8;
    optional int32s maxPower = 9;
    optional int32s nominalEnergy = 10;
    optional CostStruct costs[] = 11;
    optional int32s minPowerAdjustment = 12;
    optional int32s maxPowerAdjustment = 13;
    optional elapsed_s minDurationAdjustment = 14;
    optional elapsed_s maxDurationAdjustment = 15;
  }

  struct ForecastStruct {
    int16u forecastId = 0;
    nullable int16u activeSlotNumber = 1;
    epoch_s startTime = 2;
    optional epoch_s endTime = 3;
    optional nullable epoch_s earliestStartTime = 4;
    optional epoch_s latestEndTime = 5;
    boolean isPauseable = 6;
    SlotStruct slots[] = 7;
  }

  struct ConstraintsStruct {
    epoch_s startTime = 0;
    elapsed_s duration = 1;
    optional int32s nominalPower = 2;
    optional int32s maximumEnergy = 3;
    optional int8s loadControl = 4;
  }

  struct PowerAdjustStruct {
    int32s minPower = 0;
    int32s maxPower = 1;
    elapsed_s minDuration = 2;
    elapsed_s maxDuration = 3;
  }

  struct SlotAdjustmentStruct {
    int8u slotIndex = 0;
    int32s nominalPower = 1;
    elapsed_s duration = 2;
  }

  info event PowerAdjustStart = 0 {
  }

  info event PowerAdjustEnd = 1 {
    CauseEnum cause = 0;
    elapsed_s duration = 1;
    INT32S energyUse = 2;
  }

  info event Paused = 2 {
  }

  info event Resumed = 3 {
  }

  readonly attribute EsaTypeEnum esaType = 0;
  readonly attribute boolean esaIsGenerator = 1;
  readonly attribute EsaStateEnum esaState = 2;
  readonly attribute int32s absMinPower = 3;
  readonly attribute int32s absMaxPower = 4;
  readonly attribute nullable PowerAdjustStruct powerAdjustmentCapability[] = 5;
  readonly attribute nullable ForecastStruct forecast = 6;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct PowerAdjustRequestRequest {
    INT32S power = 0;
    elapsed_s duration = 1;
  }

  request struct StartTimeAdjustRequestRequest {
    epoch_s requestedStartTime = 0;
  }

  request struct ModifyForecastRequestRequest {
    INT32U forecastId = 0;
    SlotAdjustmentStruct slotAdjustments[] = 1;
  }

  request struct RequestConstraintBasedForecastRequest {
    ConstraintsStruct constraints[] = 0;
  }

  command PowerAdjustRequest(PowerAdjustRequestRequest): DefaultSuccess = 0;
  command CancelPowerAdjustRequest(): DefaultSuccess = 1;
  command StartTimeAdjustRequest(StartTimeAdjustRequestRequest): DefaultSuccess = 2;
  command PauseRequest(): DefaultSuccess = 3;
  command ResumeRequest(): DefaultSuccess = 4;
  command ModifyForecastRequest(ModifyForecastRequestRequest): DefaultSuccess = 5;
  command RequestConstraintBasedForecast(RequestConstraintBasedForecastRequest): DefaultSuccess = 6;
}

/** This cluster provides an interface for the management of Electric Vehicle Supply Equipment (EVSE). */
provisional server cluster EnergyEvse = 153 {
  enum EnergyTransferStoppedReasonEnum : enum8 {
    kEvStopped = 0;
    kEvseStopped = 1;
    kOther = 2;
  }

  enum EvseStateEnum : enum8 {
    kNotPluggedIn = 0;
    kPluggedInNoDemand = 1;
    kPluggedInDemand = 2;
    kPluggedInCharging = 3;
    kPluggedInDischarging = 4;
    kSessionEnding = 5;
    kFault = 6;
  }

  enum FaultStateEnum : enum8 {
    kNoError = 0;
    kEvseMeterFailure = 1;
    kOverVoltage = 2;
    kUnderVoltage = 3;
    kOverCurrent = 4;
    kContactWetFailure = 5;
    kContactDryFailure = 6;
    kGroundFault = 7;
    kPowerLoss = 8;
    kPowerQuality = 9;
    kPilotShortCircuit = 10;
    kEmergencyStop = 11;
    kEvDisconnected = 12;
    kWrongPowerSupply = 13;
    kLiveNeutralSwap = 14;
    kOverTemperature = 15;
    kOther = 255;
  }

  enum SupplyStateEnum : enum8 {
    kDisabled = 0;
    kChargingEnabled = 1;
    kDischargingEnabled = 2;
    kDisabledError = 3;
    kDisabledDiagnostics = 4;
  }

  bitmap Feature : bitmap32 {
    kChargingPreferences = 0x1;
    kSessions = 0x2;
    kSoCReporting = 0x4;
    kPlugAndCharge = 0x8;
    kRFID = 0x10;
    kV2X = 0x20;
  }

  bitmap TargetDayOfWeekBitmap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  struct ChargingTargetStruct {
    int16u targetTime = 0;
    optional percent targetSoC = 1;
    optional int32s addedEnergy = 2;
  }

  info event EVConnected = 0 {
    INT32U sessionId = 0;
  }

  info event EVNotDetected = 1 {
    INT32U sessionId = 0;
    EvseStateEnum state = 1;
    elapsed_s sessionDuration = 2;
    INT32S sessionEnergyCharged = 3;
    INT32S sessionEnergyDischarged = 4;
  }

  info event EnergyTransferStarted = 2 {
    INT32U sessionId = 0;
    EvseStateEnum state = 1;
    INT32U maximumCurrent = 2;
  }

  info event EnergyTransferStopped = 3 {
    INT32U sessionId = 0;
    EvseStateEnum state = 1;
    EnergyTransferStoppedReasonEnum reason = 2;
    INT32S energyTransferred = 4;
  }

  critical event Fault = 4 {
    INT32U sessionId = 0;
    EvseStateEnum state = 1;
    EvseStateEnum faultStatePreviousState = 2;
    EvseStateEnum faultStateCurrentState = 4;
  }

  info event RFID = 5 {
    OCTET_STRING uid = 0;
  }

  readonly attribute nullable EvseStateEnum state = 0;
  readonly attribute SupplyStateEnum supplyState = 1;
  readonly attribute FaultStateEnum faultState = 2;
  readonly attribute nullable elapsed_s enableChargeTime = 3;
  readonly attribute nullable elapsed_s enableDischargeTime = 4;
  readonly attribute int32u circuitCapacity = 5;
  readonly attribute int32u minimumChargeCurrent = 6;
  readonly attribute int32u maximumChargeCurrent = 7;
  readonly attribute int32u maximumDischargeCurrent = 8;
  attribute access(write: manage) int32u userMaximumChargeCurrent = 9;
  attribute access(write: manage) elapsed_s randomisationDelayWindow = 10;
  readonly attribute int8u numberOfWeeklyTargets = 33;
  readonly attribute int8u numberOfDailyTargets = 34;
  readonly attribute nullable epoch_s nextChargeStartTime = 35;
  readonly attribute nullable epoch_s nextChargeTargetTime = 36;
  readonly attribute nullable int32s nextChargeRequiredEnergy = 37;
  readonly attribute nullable int8u nextChargeTargetSoc = 38;
  attribute access(write: manage) nullable int16u approxEvEfficiency = 39;
  readonly attribute nullable Percent stateOfCharge = 48;
  readonly attribute nullable int32s batteryCapacity = 49;
  readonly attribute nullable char_string<32> vehicleId = 50;
  readonly attribute int32u sessionId = 64;
  readonly attribute int16u eventSequenceNumber = 65;
  readonly attribute elapsed_s sessionDuration = 66;
  readonly attribute int32s sessionEnergyCharged = 67;
  readonly attribute int32s sessionEnergyDischarged = 68;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct EnableChargingRequest {
    nullable elapsed_s enableChargeTime = 0;
    INT32U minimumChargeCurrent = 1;
    INT32U maximumChargeCurrent = 2;
  }

  request struct EnableDischargingRequest {
    nullable elapsed_s enableDischargeTime = 0;
    INT32U maximumDischargeCurrent = 1;
  }

  request struct SetTargetsRequest {
    TargetDayOfWeekBitmap dayOfWeekForSequence = 0;
    ChargingTargetStruct chargingTargets[] = 1;
  }

  request struct GetTargetsRequest {
    TargetDayOfWeekBitmap daysToReturn = 0;
  }

  response struct GetTargetsResponse = 0 {
    TargetDayOfWeekBitmap dayOfWeekForSequence = 0;
    ChargingTargetStruct chargingTargets[] = 1;
  }

  command Disable(): DefaultSuccess = 1;
  command EnableCharging(EnableChargingRequest): DefaultSuccess = 2;
  command EnableDischarging(EnableDischargingRequest): DefaultSuccess = 3;
  command StartDiagnostics(): DefaultSuccess = 4;
  command SetTargets(SetTargetsRequest): DefaultSuccess = 5;
  command GetTargets(GetTargetsRequest): DefaultSuccess = 6;
  command ClearTargets(): DefaultSuccess = 7;
}

/** An interface to a generic way to secure a door */
client cluster DoorLock = 257 {
  enum AlarmCodeEnum : enum8 {
    kLockJammed = 0;
    kLockFactoryReset = 1;
    kLockRadioPowerCycled = 3;
    kWrongCodeEntryLimit = 4;
    kFrontEsceutcheonRemoved = 5;
    kDoorForcedOpen = 6;
    kDoorAjar = 7;
    kForcedUser = 8;
  }

  enum CredentialRuleEnum : enum8 {
    kSingle = 0;
    kDual = 1;
    kTri = 2;
  }

  enum CredentialTypeEnum : enum8 {
    kProgrammingPIN = 0;
    kPIN = 1;
    kRFID = 2;
    kFingerprint = 3;
    kFingerVein = 4;
    kFace = 5;
  }

  enum DataOperationTypeEnum : enum8 {
    kAdd = 0;
    kClear = 1;
    kModify = 2;
  }

  enum DlLockState : enum8 {
    kNotFullyLocked = 0;
    kLocked = 1;
    kUnlocked = 2;
    kUnlatched = 3;
  }

  enum DlLockType : enum8 {
    kDeadBolt = 0;
    kMagnetic = 1;
    kOther = 2;
    kMortise = 3;
    kRim = 4;
    kLatchBolt = 5;
    kCylindricalLock = 6;
    kTubularLock = 7;
    kInterconnectedLock = 8;
    kDeadLatch = 9;
    kDoorFurniture = 10;
    kEurocylinder = 11;
  }

  enum DlStatus : enum8 {
    kSuccess = 0;
    kFailure = 1;
    kDuplicate = 2;
    kOccupied = 3;
    kInvalidField = 133;
    kResourceExhausted = 137;
    kNotFound = 139;
  }

  enum DoorLockOperationEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kLock = 1;
    kUnlock = 2;
    kLockInvalidPinOrId = 3;
    kLockInvalidSchedule = 4;
    kUnlockInvalidPinOrId = 5;
    kUnlockInvalidSchedule = 6;
    kOneTouchLock = 7;
    kKeyLock = 8;
    kKeyUnlock = 9;
    kAutoLock = 10;
    kScheduleLock = 11;
    kScheduleUnlock = 12;
    kManualLock = 13;
    kManualUnlock = 14;
  }

  enum DoorLockProgrammingEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kMasterCodeChanged = 1;
    kPinAdded = 2;
    kPinDeleted = 3;
    kPinChanged = 4;
    kIdAdded = 5;
    kIdDeleted = 6;
  }

  enum DoorLockSetPinOrIdStatus : enum8 {
    kSuccess = 0;
    kGeneralFailure = 1;
    kMemoryFull = 2;
    kDuplicateCodeError = 3;
  }

  enum DoorLockUserStatus : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
    kNotSupported = 255;
  }

  enum DoorLockUserType : enum8 {
    kUnrestricted = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kMasterUser = 3;
    kNonAccessUser = 4;
    kNotSupported = 255;
  }

  enum DoorStateEnum : enum8 {
    kDoorOpen = 0;
    kDoorClosed = 1;
    kDoorJammed = 2;
    kDoorForcedOpen = 3;
    kDoorUnspecifiedError = 4;
    kDoorAjar = 5;
  }

  enum LockDataTypeEnum : enum8 {
    kUnspecified = 0;
    kProgrammingCode = 1;
    kUserIndex = 2;
    kWeekDaySchedule = 3;
    kYearDaySchedule = 4;
    kHolidaySchedule = 5;
    kPIN = 6;
    kRFID = 7;
    kFingerprint = 8;
    kFingerVein = 9;
    kFace = 10;
  }

  enum LockOperationTypeEnum : enum8 {
    kLock = 0;
    kUnlock = 1;
    kNonAccessUserEvent = 2;
    kForcedUserEvent = 3;
    kUnlatch = 4;
  }

  enum OperatingModeEnum : enum8 {
    kNormal = 0;
    kVacation = 1;
    kPrivacy = 2;
    kNoRemoteLockUnlock = 3;
    kPassage = 4;
  }

  enum OperationErrorEnum : enum8 {
    kUnspecified = 0;
    kInvalidCredential = 1;
    kDisabledUserDenied = 2;
    kRestricted = 3;
    kInsufficientBattery = 4;
  }

  enum OperationSourceEnum : enum8 {
    kUnspecified = 0;
    kManual = 1;
    kProprietaryRemote = 2;
    kKeypad = 3;
    kAuto = 4;
    kButton = 5;
    kSchedule = 6;
    kRemote = 7;
    kRFID = 8;
    kBiometric = 9;
  }

  enum UserStatusEnum : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
  }

  enum UserTypeEnum : enum8 {
    kUnrestrictedUser = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kProgrammingUser = 3;
    kNonAccessUser = 4;
    kForcedUser = 5;
    kDisposableUser = 6;
    kExpiringUser = 7;
    kScheduleRestrictedUser = 8;
    kRemoteOnlyUser = 9;
  }

  bitmap DaysMaskMap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap DlCredentialRuleMask : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlCredentialRulesSupport : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlDefaultConfigurationRegister : bitmap16 {
    kEnableLocalProgrammingEnabled = 0x1;
    kKeypadInterfaceDefaultAccessEnabled = 0x2;
    kRemoteInterfaceDefaultAccessIsEnabled = 0x4;
    kSoundEnabled = 0x20;
    kAutoRelockTimeSet = 0x40;
    kLEDSettingsSet = 0x80;
  }

  bitmap DlKeypadOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidPIN = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
    kNonAccessUserOpEvent = 0x80;
  }

  bitmap DlKeypadProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
  }

  bitmap DlLocalProgrammingFeatures : bitmap8 {
    kAddUsersCredentialsSchedulesLocally = 0x1;
    kModifyUsersCredentialsSchedulesLocally = 0x2;
    kClearUsersCredentialsSchedulesLocally = 0x4;
    kAdjustLockSettingsLocally = 0x8;
  }

  bitmap DlManualOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kThumbturnLock = 0x2;
    kThumbturnUnlock = 0x4;
    kOneTouchLock = 0x8;
    kKeyLock = 0x10;
    kKeyUnlock = 0x20;
    kAutoLock = 0x40;
    kScheduleLock = 0x80;
    kScheduleUnlock = 0x100;
    kManualLock = 0x200;
    kManualUnlock = 0x400;
  }

  bitmap DlRFIDOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidRFID = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidRFID = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRFIDProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlRemoteOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidCode = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRemoteProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlSupportedOperatingModes : bitmap16 {
    kNormal = 0x1;
    kVacation = 0x2;
    kPrivacy = 0x4;
    kNoRemoteLockUnlock = 0x8;
    kPassage = 0x10;
  }

  bitmap DoorLockDayOfWeek : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap Feature : bitmap32 {
    kPINCredential = 0x1;
    kRFIDCredential = 0x2;
    kFingerCredentials = 0x4;
    kLogging = 0x8;
    kWeekDayAccessSchedules = 0x10;
    kDoorPositionSensor = 0x20;
    kFaceCredentials = 0x40;
    kCredentialsOverTheAirAccess = 0x80;
    kUser = 0x100;
    kNotification = 0x200;
    kYearDayAccessSchedules = 0x400;
    kHolidaySchedules = 0x800;
    kUnbolt = 0x1000;
  }

  struct CredentialStruct {
    CredentialTypeEnum credentialType = 0;
    int16u credentialIndex = 1;
  }

  critical event DoorLockAlarm = 0 {
    AlarmCodeEnum alarmCode = 0;
  }

  critical event DoorStateChange = 1 {
    DoorStateEnum doorState = 0;
  }

  critical event LockOperation = 2 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    nullable int16u userIndex = 2;
    nullable fabric_idx fabricIndex = 3;
    nullable node_id sourceNode = 4;
    optional nullable CredentialStruct credentials[] = 5;
  }

  critical event LockOperationError = 3 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    OperationErrorEnum operationError = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    optional nullable CredentialStruct credentials[] = 6;
  }

  info event LockUserChange = 4 {
    LockDataTypeEnum lockDataType = 0;
    DataOperationTypeEnum dataOperationType = 1;
    OperationSourceEnum operationSource = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    nullable int16u dataIndex = 6;
  }

  readonly attribute nullable DlLockState lockState = 0;
  readonly attribute DlLockType lockType = 1;
  readonly attribute boolean actuatorEnabled = 2;
  readonly attribute optional nullable DoorStateEnum doorState = 3;
  attribute access(write: manage) optional int32u doorOpenEvents = 4;
  attribute access(write: manage) optional int32u doorClosedEvents = 5;
  attribute access(write: manage) optional int16u openPeriod = 6;
  readonly attribute optional int16u numberOfTotalUsersSupported = 17;
  readonly attribute optional int16u numberOfPINUsersSupported = 18;
  readonly attribute optional int16u numberOfRFIDUsersSupported = 19;
  readonly attribute optional int8u numberOfWeekDaySchedulesSupportedPerUser = 20;
  readonly attribute optional int8u numberOfYearDaySchedulesSupportedPerUser = 21;
  readonly attribute optional int8u numberOfHolidaySchedulesSupported = 22;
  readonly attribute optional int8u maxPINCodeLength = 23;
  readonly attribute optional int8u minPINCodeLength = 24;
  readonly attribute optional int8u maxRFIDCodeLength = 25;
  readonly attribute optional int8u minRFIDCodeLength = 26;
  readonly attribute optional DlCredentialRuleMask credentialRulesSupport = 27;
  readonly attribute optional int8u numberOfCredentialsSupportedPerUser = 28;
  attribute access(write: manage) optional char_string<3> language = 33;
  attribute access(write: manage) optional int8u LEDSettings = 34;
  attribute access(write: manage) int32u autoRelockTime = 35;
  attribute access(write: manage) optional int8u soundVolume = 36;
  attribute access(write: manage) OperatingModeEnum operatingMode = 37;
  readonly attribute DlSupportedOperatingModes supportedOperatingModes = 38;
  readonly attribute optional DlDefaultConfigurationRegister defaultConfigurationRegister = 39;
  attribute access(write: administer) optional boolean enableLocalProgramming = 40;
  attribute access(write: manage) optional boolean enableOneTouchLocking = 41;
  attribute access(write: manage) optional boolean enableInsideStatusLED = 42;
  attribute access(write: manage) optional boolean enablePrivacyModeButton = 43;
  attribute access(write: administer) optional DlLocalProgrammingFeatures localProgrammingFeatures = 44;
  attribute access(write: administer) optional int8u wrongCodeEntryLimit = 48;
  attribute access(write: administer) optional int8u userCodeTemporaryDisableTime = 49;
  attribute access(write: administer) optional boolean sendPINOverTheAir = 50;
  attribute access(write: administer) optional boolean requirePINforRemoteOperation = 51;
  attribute access(write: administer) optional int16u expiringUserTimeout = 53;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockWithTimeoutRequest {
    int16u timeout = 0;
    optional octet_string PINCode = 1;
  }

  request struct SetWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
    DaysMaskMap daysMask = 2;
    int8u startHour = 3;
    int8u startMinute = 4;
    int8u endHour = 5;
    int8u endMinute = 6;
  }

  request struct GetWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
  }

  response struct GetWeekDayScheduleResponse = 12 {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
    DlStatus status = 2;
    optional DaysMaskMap daysMask = 3;
    optional int8u startHour = 4;
    optional int8u startMinute = 5;
    optional int8u endHour = 6;
    optional int8u endMinute = 7;
  }

  request struct ClearWeekDayScheduleRequest {
    int8u weekDayIndex = 0;
    int16u userIndex = 1;
  }

  request struct SetYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
    epoch_s localStartTime = 2;
    epoch_s localEndTime = 3;
  }

  request struct GetYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
  }

  response struct GetYearDayScheduleResponse = 15 {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
    DlStatus status = 2;
    optional epoch_s localStartTime = 3;
    optional epoch_s localEndTime = 4;
  }

  request struct ClearYearDayScheduleRequest {
    int8u yearDayIndex = 0;
    int16u userIndex = 1;
  }

  request struct SetHolidayScheduleRequest {
    int8u holidayIndex = 0;
    epoch_s localStartTime = 1;
    epoch_s localEndTime = 2;
    OperatingModeEnum operatingMode = 3;
  }

  request struct GetHolidayScheduleRequest {
    int8u holidayIndex = 0;
  }

  response struct GetHolidayScheduleResponse = 18 {
    int8u holidayIndex = 0;
    DlStatus status = 1;
    optional epoch_s localStartTime = 2;
    optional epoch_s localEndTime = 3;
    optional OperatingModeEnum operatingMode = 4;
  }

  request struct ClearHolidayScheduleRequest {
    int8u holidayIndex = 0;
  }

  request struct SetUserRequest {
    DataOperationTypeEnum operationType = 0;
    int16u userIndex = 1;
    nullable char_string userName = 2;
    nullable int32u userUniqueID = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
    nullable CredentialRuleEnum credentialRule = 6;
  }

  request struct GetUserRequest {
    int16u userIndex = 0;
  }

  response struct GetUserResponse = 28 {
    int16u userIndex = 0;
    nullable char_string userName = 1;
    nullable int32u userUniqueID = 2;
    nullable UserStatusEnum userStatus = 3;
    nullable UserTypeEnum userType = 4;
    nullable CredentialRuleEnum credentialRule = 5;
    nullable CredentialStruct credentials[] = 6;
    nullable fabric_idx creatorFabricIndex = 7;
    nullable fabric_idx lastModifiedFabricIndex = 8;
    nullable int16u nextUserIndex = 9;
  }

  request struct ClearUserRequest {
    int16u userIndex = 0;
  }

  request struct SetCredentialRequest {
    DataOperationTypeEnum operationType = 0;
    CredentialStruct credential = 1;
    LONG_OCTET_STRING credentialData = 2;
    nullable int16u userIndex = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
  }

  response struct SetCredentialResponse = 35 {
    DlStatus status = 0;
    nullable int16u userIndex = 1;
    nullable int16u nextCredentialIndex = 2;
  }

  request struct GetCredentialStatusRequest {
    CredentialStruct credential = 0;
  }

  response struct GetCredentialStatusResponse = 37 {
    boolean credentialExists = 0;
    nullable int16u userIndex = 1;
    nullable fabric_idx creatorFabricIndex = 2;
    nullable fabric_idx lastModifiedFabricIndex = 3;
    nullable int16u nextCredentialIndex = 4;
  }

  request struct ClearCredentialRequest {
    nullable CredentialStruct credential = 0;
  }

  request struct UnboltDoorRequest {
    optional octet_string PINCode = 0;
  }

  /** This command causes the lock device to lock the door. */
  timed command LockDoor(LockDoorRequest): DefaultSuccess = 0;
  /** This command causes the lock device to unlock the door. */
  timed command UnlockDoor(UnlockDoorRequest): DefaultSuccess = 1;
  /** This command causes the lock device to unlock the door with a timeout parameter. */
  timed command UnlockWithTimeout(UnlockWithTimeoutRequest): DefaultSuccess = 3;
  /** Set a weekly repeating schedule for a specified user. */
  command access(invoke: administer) SetWeekDaySchedule(SetWeekDayScheduleRequest): DefaultSuccess = 11;
  /** Retrieve the specific weekly schedule for the specific user. */
  command access(invoke: administer) GetWeekDaySchedule(GetWeekDayScheduleRequest): GetWeekDayScheduleResponse = 12;
  /** Clear the specific weekly schedule or all weekly schedules for the specific user. */
  command access(invoke: administer) ClearWeekDaySchedule(ClearWeekDayScheduleRequest): DefaultSuccess = 13;
  /** Set a time-specific schedule ID for a specified user. */
  command access(invoke: administer) SetYearDaySchedule(SetYearDayScheduleRequest): DefaultSuccess = 14;
  /** Returns the year day schedule data for the specified schedule and user indexes. */
  command access(invoke: administer) GetYearDaySchedule(GetYearDayScheduleRequest): GetYearDayScheduleResponse = 15;
  /** Clears the specific year day schedule or all year day schedules for the specific user. */
  command access(invoke: administer) ClearYearDaySchedule(ClearYearDayScheduleRequest): DefaultSuccess = 16;
  /** Set the holiday Schedule by specifying local start time and local end time with respect to any Lock Operating Mode. */
  command access(invoke: administer) SetHolidaySchedule(SetHolidayScheduleRequest): DefaultSuccess = 17;
  /** Get the holiday schedule for the specified index. */
  command access(invoke: administer) GetHolidaySchedule(GetHolidayScheduleRequest): GetHolidayScheduleResponse = 18;
  /** Clears the holiday schedule or all holiday schedules. */
  command access(invoke: administer) ClearHolidaySchedule(ClearHolidayScheduleRequest): DefaultSuccess = 19;
  /** Set User into the lock. */
  timed command access(invoke: administer) SetUser(SetUserRequest): DefaultSuccess = 26;
  /** Retrieve User. */
  command access(invoke: administer) GetUser(GetUserRequest): GetUserResponse = 27;
  /** Clears a User or all Users. */
  timed command access(invoke: administer) ClearUser(ClearUserRequest): DefaultSuccess = 29;
  /** Set a credential (e.g. PIN, RFID, Fingerprint, etc.) into the lock for a new user, existing user, or ProgrammingUser. */
  timed command access(invoke: administer) SetCredential(SetCredentialRequest): SetCredentialResponse = 34;
  /** Retrieve the status of a particular credential (e.g. PIN, RFID, Fingerprint, etc.) by index. */
  command access(invoke: administer) GetCredentialStatus(GetCredentialStatusRequest): GetCredentialStatusResponse = 36;
  /** Clear one, one type, or all credentials except ProgrammingPIN credential. */
  timed command access(invoke: administer) ClearCredential(ClearCredentialRequest): DefaultSuccess = 38;
  /** This command causes the lock device to unlock the door without pulling the latch. */
  timed command UnboltDoor(UnboltDoorRequest): DefaultSuccess = 39;
}

/** An interface to a generic way to secure a door */
server cluster DoorLock = 257 {
  enum AlarmCodeEnum : enum8 {
    kLockJammed = 0;
    kLockFactoryReset = 1;
    kLockRadioPowerCycled = 3;
    kWrongCodeEntryLimit = 4;
    kFrontEsceutcheonRemoved = 5;
    kDoorForcedOpen = 6;
    kDoorAjar = 7;
    kForcedUser = 8;
  }

  enum CredentialRuleEnum : enum8 {
    kSingle = 0;
    kDual = 1;
    kTri = 2;
  }

  enum CredentialTypeEnum : enum8 {
    kProgrammingPIN = 0;
    kPIN = 1;
    kRFID = 2;
    kFingerprint = 3;
    kFingerVein = 4;
    kFace = 5;
  }

  enum DataOperationTypeEnum : enum8 {
    kAdd = 0;
    kClear = 1;
    kModify = 2;
  }

  enum DlLockState : enum8 {
    kNotFullyLocked = 0;
    kLocked = 1;
    kUnlocked = 2;
    kUnlatched = 3;
  }

  enum DlLockType : enum8 {
    kDeadBolt = 0;
    kMagnetic = 1;
    kOther = 2;
    kMortise = 3;
    kRim = 4;
    kLatchBolt = 5;
    kCylindricalLock = 6;
    kTubularLock = 7;
    kInterconnectedLock = 8;
    kDeadLatch = 9;
    kDoorFurniture = 10;
    kEurocylinder = 11;
  }

  enum DlStatus : enum8 {
    kSuccess = 0;
    kFailure = 1;
    kDuplicate = 2;
    kOccupied = 3;
    kInvalidField = 133;
    kResourceExhausted = 137;
    kNotFound = 139;
  }

  enum DoorLockOperationEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kLock = 1;
    kUnlock = 2;
    kLockInvalidPinOrId = 3;
    kLockInvalidSchedule = 4;
    kUnlockInvalidPinOrId = 5;
    kUnlockInvalidSchedule = 6;
    kOneTouchLock = 7;
    kKeyLock = 8;
    kKeyUnlock = 9;
    kAutoLock = 10;
    kScheduleLock = 11;
    kScheduleUnlock = 12;
    kManualLock = 13;
    kManualUnlock = 14;
  }

  enum DoorLockProgrammingEventCode : enum8 {
    kUnknownOrMfgSpecific = 0;
    kMasterCodeChanged = 1;
    kPinAdded = 2;
    kPinDeleted = 3;
    kPinChanged = 4;
    kIdAdded = 5;
    kIdDeleted = 6;
  }

  enum DoorLockSetPinOrIdStatus : enum8 {
    kSuccess = 0;
    kGeneralFailure = 1;
    kMemoryFull = 2;
    kDuplicateCodeError = 3;
  }

  enum DoorLockUserStatus : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
    kNotSupported = 255;
  }

  enum DoorLockUserType : enum8 {
    kUnrestricted = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kMasterUser = 3;
    kNonAccessUser = 4;
    kNotSupported = 255;
  }

  enum DoorStateEnum : enum8 {
    kDoorOpen = 0;
    kDoorClosed = 1;
    kDoorJammed = 2;
    kDoorForcedOpen = 3;
    kDoorUnspecifiedError = 4;
    kDoorAjar = 5;
  }

  enum LockDataTypeEnum : enum8 {
    kUnspecified = 0;
    kProgrammingCode = 1;
    kUserIndex = 2;
    kWeekDaySchedule = 3;
    kYearDaySchedule = 4;
    kHolidaySchedule = 5;
    kPIN = 6;
    kRFID = 7;
    kFingerprint = 8;
    kFingerVein = 9;
    kFace = 10;
  }

  enum LockOperationTypeEnum : enum8 {
    kLock = 0;
    kUnlock = 1;
    kNonAccessUserEvent = 2;
    kForcedUserEvent = 3;
    kUnlatch = 4;
  }

  enum OperatingModeEnum : enum8 {
    kNormal = 0;
    kVacation = 1;
    kPrivacy = 2;
    kNoRemoteLockUnlock = 3;
    kPassage = 4;
  }

  enum OperationErrorEnum : enum8 {
    kUnspecified = 0;
    kInvalidCredential = 1;
    kDisabledUserDenied = 2;
    kRestricted = 3;
    kInsufficientBattery = 4;
  }

  enum OperationSourceEnum : enum8 {
    kUnspecified = 0;
    kManual = 1;
    kProprietaryRemote = 2;
    kKeypad = 3;
    kAuto = 4;
    kButton = 5;
    kSchedule = 6;
    kRemote = 7;
    kRFID = 8;
    kBiometric = 9;
  }

  enum UserStatusEnum : enum8 {
    kAvailable = 0;
    kOccupiedEnabled = 1;
    kOccupiedDisabled = 3;
  }

  enum UserTypeEnum : enum8 {
    kUnrestrictedUser = 0;
    kYearDayScheduleUser = 1;
    kWeekDayScheduleUser = 2;
    kProgrammingUser = 3;
    kNonAccessUser = 4;
    kForcedUser = 5;
    kDisposableUser = 6;
    kExpiringUser = 7;
    kScheduleRestrictedUser = 8;
    kRemoteOnlyUser = 9;
  }

  bitmap DaysMaskMap : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap DlCredentialRuleMask : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlCredentialRulesSupport : bitmap8 {
    kSingle = 0x1;
    kDual = 0x2;
    kTri = 0x4;
  }

  bitmap DlDefaultConfigurationRegister : bitmap16 {
    kEnableLocalProgrammingEnabled = 0x1;
    kKeypadInterfaceDefaultAccessEnabled = 0x2;
    kRemoteInterfaceDefaultAccessIsEnabled = 0x4;
    kSoundEnabled = 0x20;
    kAutoRelockTimeSet = 0x40;
    kLEDSettingsSet = 0x80;
  }

  bitmap DlKeypadOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidPIN = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
    kNonAccessUserOpEvent = 0x80;
  }

  bitmap DlKeypadProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
  }

  bitmap DlLocalProgrammingFeatures : bitmap8 {
    kAddUsersCredentialsSchedulesLocally = 0x1;
    kModifyUsersCredentialsSchedulesLocally = 0x2;
    kClearUsersCredentialsSchedulesLocally = 0x4;
    kAdjustLockSettingsLocally = 0x8;
  }

  bitmap DlManualOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kThumbturnLock = 0x2;
    kThumbturnUnlock = 0x4;
    kOneTouchLock = 0x8;
    kKeyLock = 0x10;
    kKeyUnlock = 0x20;
    kAutoLock = 0x40;
    kScheduleLock = 0x80;
    kScheduleUnlock = 0x100;
    kManualLock = 0x200;
    kManualUnlock = 0x400;
  }

  bitmap DlRFIDOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidRFID = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidRFID = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRFIDProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlRemoteOperationEventMask : bitmap16 {
    kUnknown = 0x1;
    kLock = 0x2;
    kUnlock = 0x4;
    kLockInvalidCode = 0x8;
    kLockInvalidSchedule = 0x10;
    kUnlockInvalidCode = 0x20;
    kUnlockInvalidSchedule = 0x40;
  }

  bitmap DlRemoteProgrammingEventMask : bitmap16 {
    kUnknown = 0x1;
    kProgrammingPINChanged = 0x2;
    kPINAdded = 0x4;
    kPINCleared = 0x8;
    kPINChanged = 0x10;
    kRFIDCodeAdded = 0x20;
    kRFIDCodeCleared = 0x40;
  }

  bitmap DlSupportedOperatingModes : bitmap16 {
    kNormal = 0x1;
    kVacation = 0x2;
    kPrivacy = 0x4;
    kNoRemoteLockUnlock = 0x8;
    kPassage = 0x10;
  }

  bitmap DoorLockDayOfWeek : bitmap8 {
    kSunday = 0x1;
    kMonday = 0x2;
    kTuesday = 0x4;
    kWednesday = 0x8;
    kThursday = 0x10;
    kFriday = 0x20;
    kSaturday = 0x40;
  }

  bitmap Feature : bitmap32 {
    kPINCredential = 0x1;
    kRFIDCredential = 0x2;
    kFingerCredentials = 0x4;
    kLogging = 0x8;
    kWeekDayAccessSchedules = 0x10;
    kDoorPositionSensor = 0x20;
    kFaceCredentials = 0x40;
    kCredentialsOverTheAirAccess = 0x80;
    kUser = 0x100;
    kNotification = 0x200;
    kYearDayAccessSchedules = 0x400;
    kHolidaySchedules = 0x800;
    kUnbolt = 0x1000;
  }

  struct CredentialStruct {
    CredentialTypeEnum credentialType = 0;
    int16u credentialIndex = 1;
  }

  critical event DoorLockAlarm = 0 {
    AlarmCodeEnum alarmCode = 0;
  }

  critical event DoorStateChange = 1 {
    DoorStateEnum doorState = 0;
  }

  critical event LockOperation = 2 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    nullable int16u userIndex = 2;
    nullable fabric_idx fabricIndex = 3;
    nullable node_id sourceNode = 4;
    optional nullable CredentialStruct credentials[] = 5;
  }

  critical event LockOperationError = 3 {
    LockOperationTypeEnum lockOperationType = 0;
    OperationSourceEnum operationSource = 1;
    OperationErrorEnum operationError = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    optional nullable CredentialStruct credentials[] = 6;
  }

  info event LockUserChange = 4 {
    LockDataTypeEnum lockDataType = 0;
    DataOperationTypeEnum dataOperationType = 1;
    OperationSourceEnum operationSource = 2;
    nullable int16u userIndex = 3;
    nullable fabric_idx fabricIndex = 4;
    nullable node_id sourceNode = 5;
    nullable int16u dataIndex = 6;
  }

  readonly attribute nullable DlLockState lockState = 0;
  readonly attribute DlLockType lockType = 1;
  readonly attribute boolean actuatorEnabled = 2;
  attribute access(write: manage) int32u autoRelockTime = 35;
  attribute access(write: manage) OperatingModeEnum operatingMode = 37;
  readonly attribute DlSupportedOperatingModes supportedOperatingModes = 38;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct LockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct UnlockDoorRequest {
    optional octet_string PINCode = 0;
  }

  request struct SetUserRequest {
    DataOperationTypeEnum operationType = 0;
    int16u userIndex = 1;
    nullable char_string userName = 2;
    nullable int32u userUniqueID = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
    nullable CredentialRuleEnum credentialRule = 6;
  }

  request struct GetUserRequest {
    int16u userIndex = 0;
  }

  request struct ClearUserRequest {
    int16u userIndex = 0;
  }

  request struct SetCredentialRequest {
    DataOperationTypeEnum operationType = 0;
    CredentialStruct credential = 1;
    LONG_OCTET_STRING credentialData = 2;
    nullable int16u userIndex = 3;
    nullable UserStatusEnum userStatus = 4;
    nullable UserTypeEnum userType = 5;
  }

  request struct ClearCredentialRequest {
    nullable CredentialStruct credential = 0;
  }

  response struct GetUserResponse = 28 {
    int16u userIndex = 0;
    nullable char_string userName = 1;
    nullable int32u userUniqueID = 2;
    nullable UserStatusEnum userStatus = 3;
    nullable UserTypeEnum userType = 4;
    nullable CredentialRuleEnum credentialRule = 5;
    nullable CredentialStruct credentials[] = 6;
    nullable fabric_idx creatorFabricIndex = 7;
    nullable fabric_idx lastModifiedFabricIndex = 8;
    nullable int16u nextUserIndex = 9;
  }

  response struct SetCredentialResponse = 35 {
    DlStatus status = 0;
    nullable int16u userIndex = 1;
    nullable int16u nextCredentialIndex = 2;
  }

  timed command LockDoor(LockDoorRequest): DefaultSuccess = 0;
  timed command UnlockDoor(UnlockDoorRequest): DefaultSuccess = 1;
  timed command access(invoke: administer) SetUser(SetUserRequest): DefaultSuccess = 26;
  command access(invoke: administer) GetUser(GetUserRequest): GetUserResponse = 27;
  timed command access(invoke: administer) ClearUser(ClearUserRequest): DefaultSuccess = 29;
  timed command access(invoke: administer) SetCredential(SetCredentialRequest): SetCredentialResponse = 34;
  timed command access(invoke: administer) ClearCredential(ClearCredentialRequest): DefaultSuccess = 38;
}

/** This cluster provides control of a barrier (garage door). */
client cluster BarrierControl = 259 {
  bitmap BarrierControlCapabilities : bitmap8 {
    kPartialBarrier = 0x1;
  }

  bitmap BarrierControlSafetyStatus : bitmap16 {
    kRemoteLockout = 0x1;
    kTemperDetected = 0x2;
    kFailedCommunication = 0x4;
    kPositionFailure = 0x8;
  }

  readonly attribute enum8 barrierMovingState = 1;
  readonly attribute bitmap16 barrierSafetyStatus = 2;
  readonly attribute bitmap8 barrierCapabilities = 3;
  attribute optional int16u barrierOpenEvents = 4;
  attribute optional int16u barrierCloseEvents = 5;
  attribute optional int16u barrierCommandOpenEvents = 6;
  attribute optional int16u barrierCommandCloseEvents = 7;
  attribute optional int16u barrierOpenPeriod = 8;
  attribute optional int16u barrierClosePeriod = 9;
  readonly attribute int8u barrierPosition = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct BarrierControlGoToPercentRequest {
    int8u percentOpen = 0;
  }

  /** Command to instruct a barrier to go to a percent open state. */
  command BarrierControlGoToPercent(BarrierControlGoToPercentRequest): DefaultSuccess = 0;
  /** Command that instructs the barrier to stop moving. */
  command BarrierControlStop(): DefaultSuccess = 1;
}

/** This cluster provides control of a barrier (garage door). */
server cluster BarrierControl = 259 {
  bitmap BarrierControlCapabilities : bitmap8 {
    kPartialBarrier = 0x1;
  }

  bitmap BarrierControlSafetyStatus : bitmap16 {
    kRemoteLockout = 0x1;
    kTemperDetected = 0x2;
    kFailedCommunication = 0x4;
    kPositionFailure = 0x8;
  }

  readonly attribute enum8 barrierMovingState = 1;
  readonly attribute bitmap16 barrierSafetyStatus = 2;
  readonly attribute bitmap8 barrierCapabilities = 3;
  readonly attribute int8u barrierPosition = 10;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;

  request struct BarrierControlGoToPercentRequest {
    int8u percentOpen = 0;
  }

  command BarrierControlGoToPercent(BarrierControlGoToPercentRequest): DefaultSuccess = 0;
  command BarrierControlStop(): DefaultSuccess = 1;
}

/** Attributes and commands for configuring the measurement of temperature, and reporting temperature measurements. */
server cluster TemperatureMeasurement = 1026 {
  readonly attribute nullable temperature measuredValue = 0;
  readonly attribute nullable temperature minMeasuredValue = 1;
  readonly attribute nullable temperature maxMeasuredValue = 2;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** Attributes related to the electrical properties of a device. This cluster is used by power outlets and other devices that need to provide instantaneous data as opposed to metrology data which should be retrieved from the metering cluster.. */
server cluster ElectricalMeasurement = 2820 {
  readonly attribute bitmap32 measurementType = 0;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides a mechanism for querying data about electrical power as measured by the device. */
server cluster ElectricalPowerMeasurement = 26209 {
  enum MeasurementTypeEnum : enum8 {
    kUnspecified = 0;
    kVoltage = 1;
    kCurrent = 2;
    kActivePower = 3;
    kRMSCurrent = 4;
    kRMSPower = 5;
    kApparentPower = 6;
    kReactivePower = 7;
    kFrequency = 8;
    kPowerFactor = 9;
    kLineCurrent = 10;
    kNeutralCurrent = 11;
  }

  enum PowerModeEnum : enum8 {
    kUnspecified = 0;
    kDC = 1;
    kAC = 2;
  }

  bitmap Feature : bitmap32 {
    kDirectCurrent = 0x1;
    kAlternatingCurrent = 0x2;
    kThreePhasePower = 0x4;
    kHarmonics = 0x8;
    kPowerQuality = 0x10;
  }

  struct HarmonicMeasurementStruct {
    int8u order = 0;
    nullable int32s measurement = 1;
  }

  struct MeasurementAccuracyStruct {
    MeasurementTypeEnum measurementType = 0;
    boolean measured = 1;
    optional percent100ths percentTypical = 2;
    optional percent100ths percentMin = 3;
    optional percent100ths percentMax = 4;
    optional int64s fixedTypical = 5;
    optional int64s fixedMin = 6;
    optional int64s fixedMax = 7;
  }

  struct MeasurementRangeStruct {
    MeasurementTypeEnum measurementType = 0;
    nullable int64s min = 1;
    nullable epoch_s minTimestamp = 2;
    nullable int64s max = 3;
    nullable epoch_s maxTimestamp = 4;
  }

  info event MeasurementPeriodRange = 0 {
    MeasurementTypeEnum measurementType = 0;
    epoch_s periodStart = 1;
    epoch_s periodEnd = 2;
    INT64S min = 3;
    epoch_s minTimestamp = 4;
    INT64S max = 5;
    epoch_s maxTimestamp = 6;
  }

  readonly attribute PowerModeEnum powerMode = 0;
  readonly attribute MeasurementAccuracyStruct accuracy[] = 1;
  readonly attribute MeasurementRangeStruct ranges[] = 2;
  readonly attribute nullable int64s voltage = 3;
  readonly attribute nullable int64s current = 4;
  readonly attribute nullable int64s activePower = 5;
  readonly attribute nullable int64s rmsCurrent = 6;
  readonly attribute nullable int64s rmsPower = 7;
  readonly attribute nullable int64s apparentPower = 8;
  readonly attribute nullable int64s reactivePower = 9;
  readonly attribute nullable int64s frequency = 10;
  readonly attribute nullable HarmonicMeasurementStruct harmonicCurrents[] = 11;
  readonly attribute nullable HarmonicMeasurementStruct harmonicPhases[] = 12;
  readonly attribute nullable int64s powerFactor = 13;
  readonly attribute nullable int64s lineCurrent = 14;
  readonly attribute nullable int64s neutralCurrent = 15;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

/** This cluster provides a mechanism for querying data about the electrical energy consumed or provided by the device. */
server cluster ElectricalEnergyMeasurement = 26210 {
  bitmap Feature : bitmap32 {
    kImportedEnergy = 0x1;
    kExportedEnergy = 0x2;
    kCumulativeEnergy = 0x4;
    kPeriodicEnergy = 0x8;
    kEphemeralEnergy = 0x10;
  }

  info event CumulativeEnergyImported = 0 {
    epoch_s importedTimestamp = 0;
    INT64U energyImported = 1;
  }

  info event CumulativeEnergyExported = 1 {
    epoch_s exportedTimestamp = 0;
    INT64U energyExported = 1;
  }

  info event PeriodicEnergyImported = 3 {
    epoch_s periodStart = 0;
    epoch_s periodEnd = 1;
    INT64U energyImported = 2;
  }

  info event PeriodicEnergyExported = 4 {
    epoch_s periodStart = 0;
    epoch_s periodEnd = 1;
    INT64U energyExported = 2;
  }

  info event EphemeralEnergyImported = 5 {
    systime_ms importedTimestamp = 0;
    INT64U energyImported = 1;
  }

  info event EphemeralEnergyExported = 6 {
    systime_ms exportedTimestamp = 0;
    INT64U energyExported = 1;
  }

  readonly attribute boolean measured = 0;
  readonly attribute nullable epoch_s cumulativeEnergyImportedTime = 1;
  readonly attribute nullable int64u cumulativeEnergyImported = 2;
  readonly attribute nullable epoch_s cumulativeEnergyExportedTime = 3;
  readonly attribute nullable int64u cumulativeEnergyExported = 4;
  readonly attribute nullable epoch_s periodicEnergyImportedStartTime = 5;
  readonly attribute nullable epoch_s periodicEnergyImportedEndTime = 6;
  readonly attribute nullable int64u periodicEnergyImported = 7;
  readonly attribute nullable epoch_s periodicEnergyExportedStartTime = 8;
  readonly attribute nullable epoch_s periodicEnergyExportedEndTime = 9;
  readonly attribute nullable int64u periodicEnergyExported = 10;
  readonly attribute nullable int64u ephemeralEnergyImported = 11;
  readonly attribute nullable int64u ephemeralEnergyExported = 12;
  readonly attribute command_id generatedCommandList[] = 65528;
  readonly attribute command_id acceptedCommandList[] = 65529;
  readonly attribute event_id eventList[] = 65530;
  readonly attribute attrib_id attributeList[] = 65531;
  readonly attribute bitmap32 featureMap = 65532;
  readonly attribute int16u clusterRevision = 65533;
}

endpoint 0 {
  device type ma_rootdevice = 22, version 1;

  binding cluster OtaSoftwareUpdateProvider;

  server cluster Groups {
    ram      attribute nameSupport;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command AddGroup;
    handle command AddGroupResponse;
    handle command ViewGroup;
    handle command ViewGroupResponse;
    handle command GetGroupMembership;
    handle command GetGroupMembershipResponse;
    handle command RemoveGroup;
    handle command RemoveGroupResponse;
    handle command RemoveAllGroups;
    handle command AddGroupIfIdentifying;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;
  }

  server cluster AccessControl {
    emits event AccessControlEntryChanged;
    emits event AccessControlExtensionChanged;
    callback attribute acl;
    callback attribute extension;
    callback attribute subjectsPerAccessControlEntry default = 4;
    callback attribute targetsPerAccessControlEntry default = 3;
    callback attribute accessControlEntriesPerFabric default = 4;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;
  }

  server cluster BasicInformation {
    emits event StartUp;
    emits event ShutDown;
    emits event Leave;
    callback attribute dataModelRevision default = 10;
    callback attribute vendorName;
    callback attribute vendorID;
    callback attribute productName;
    callback attribute productID;
    persist  attribute nodeLabel;
    callback attribute location default = "XX";
    callback attribute hardwareVersion default = 0;
    callback attribute hardwareVersionString;
    callback attribute softwareVersion default = 0;
    callback attribute softwareVersionString;
    callback attribute manufacturingDate default = "20210614123456ZZ";
    callback attribute partNumber;
    callback attribute productURL;
    callback attribute productLabel;
    callback attribute serialNumber;
    persist  attribute localConfigDisabled default = 0;
    ram      attribute reachable default = 1;
    callback attribute uniqueID;
    callback attribute capabilityMinima;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster OtaSoftwareUpdateRequestor {
    emits event StateTransition;
    emits event VersionApplied;
    emits event DownloadError;
    callback attribute defaultOTAProviders default = 0;
    ram      attribute updatePossible default = 1;
    ram      attribute updateState default = 0;
    ram      attribute updateStateProgress default = 0;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command AnnounceOTAProvider;
  }

  server cluster LocalizationConfiguration {
    persist  attribute activeLocale default = "en-US";
    callback attribute supportedLocales;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster TimeFormatLocalization {
    persist  attribute hourFormat default = 0;
    persist  attribute activeCalendarType default = 0;
    callback attribute supportedCalendarTypes;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster GeneralCommissioning {
    ram      attribute breadcrumb default = 0x0000000000000000;
    callback attribute basicCommissioningInfo;
    callback attribute regulatoryConfig default = 0;
    callback attribute locationCapability default = 0;
    callback attribute supportsConcurrentConnection default = 1;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command ArmFailSafe;
    handle command ArmFailSafeResponse;
    handle command SetRegulatoryConfig;
    handle command SetRegulatoryConfigResponse;
    handle command CommissioningComplete;
    handle command CommissioningCompleteResponse;
  }

  server cluster NetworkCommissioning {
    ram      attribute maxNetworks;
    callback attribute networks;
    ram      attribute scanMaxTimeSeconds;
    ram      attribute connectMaxTimeSeconds;
    ram      attribute interfaceEnabled;
    ram      attribute lastNetworkingStatus;
    ram      attribute lastNetworkID;
    ram      attribute lastConnectErrorValue;
    ram      attribute featureMap default = 2;
    ram      attribute clusterRevision default = 1;

    handle command ScanNetworks;
    handle command ScanNetworksResponse;
    handle command AddOrUpdateWiFiNetwork;
    handle command AddOrUpdateThreadNetwork;
    handle command RemoveNetwork;
    handle command NetworkConfigResponse;
    handle command ConnectNetwork;
    handle command ConnectNetworkResponse;
    handle command ReorderNetwork;
  }

  server cluster DiagnosticLogs {
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command RetrieveLogsRequest;
  }

  server cluster GeneralDiagnostics {
    emits event HardwareFaultChange;
    emits event RadioFaultChange;
    emits event NetworkFaultChange;
    emits event BootReason;
    callback attribute networkInterfaces;
    callback attribute rebootCount default = 0x0000;
    callback attribute upTime default = 0x0000000000000000;
    callback attribute totalOperationalHours default = 0x00000000;
    callback attribute bootReason;
    callback attribute activeHardwareFaults;
    callback attribute activeRadioFaults;
    callback attribute activeNetworkFaults;
    callback attribute testEventTriggersEnabled default = false;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command TestEventTrigger;
  }

  server cluster SoftwareDiagnostics {
    callback attribute threadMetrics;
    callback attribute currentHeapFree default = 0x0000000000000000;
    callback attribute currentHeapUsed default = 0x0000000000000000;
    callback attribute currentHeapHighWatermark default = 0x0000000000000000;
    callback attribute featureMap default = 1;
    ram      attribute clusterRevision default = 1;

    handle command ResetWatermarks;
  }

  server cluster ThreadNetworkDiagnostics {
    callback attribute channel;
    callback attribute routingRole;
    callback attribute networkName default = "0";
    callback attribute panId default = 0x0000;
    callback attribute extendedPanId default = 0x0000000000000000;
    callback attribute meshLocalPrefix;
    callback attribute overrunCount default = 0x0000000000000000;
    callback attribute neighborTable;
    callback attribute routeTable;
    callback attribute partitionId;
    callback attribute weighting;
    callback attribute dataVersion;
    callback attribute stableDataVersion;
    callback attribute leaderRouterId;
    callback attribute detachedRoleCount default = 0x0000;
    callback attribute childRoleCount default = 0x0000;
    callback attribute routerRoleCount default = 0x0000;
    callback attribute leaderRoleCount default = 0x0000;
    callback attribute attachAttemptCount default = 0x0000;
    callback attribute partitionIdChangeCount default = 0x0000;
    callback attribute betterPartitionAttachAttemptCount default = 0x0000;
    callback attribute parentChangeCount default = 0x0000;
    callback attribute txTotalCount default = 0x0000;
    callback attribute txUnicastCount default = 0x0000;
    callback attribute txBroadcastCount default = 0x0000;
    callback attribute txAckRequestedCount default = 0x0000;
    callback attribute txAckedCount default = 0x0000;
    callback attribute txNoAckRequestedCount default = 0x0000;
    callback attribute txDataCount default = 0x0000;
    callback attribute txDataPollCount default = 0x0000;
    callback attribute txBeaconCount default = 0x0000;
    callback attribute txBeaconRequestCount default = 0x0000;
    callback attribute txOtherCount default = 0x0000;
    callback attribute txRetryCount default = 0x0000;
    callback attribute txDirectMaxRetryExpiryCount default = 0x0000;
    callback attribute txIndirectMaxRetryExpiryCount default = 0x0000;
    callback attribute txErrCcaCount default = 0x0000;
    callback attribute txErrAbortCount default = 0x0000;
    callback attribute txErrBusyChannelCount default = 0x0000;
    callback attribute rxTotalCount default = 0x0000;
    callback attribute rxUnicastCount default = 0x0000;
    callback attribute rxBroadcastCount default = 0x0000;
    callback attribute rxDataCount default = 0x0000;
    callback attribute rxDataPollCount default = 0x0000;
    callback attribute rxBeaconCount default = 0x0000;
    callback attribute rxBeaconRequestCount default = 0x0000;
    callback attribute rxOtherCount default = 0x0000;
    callback attribute rxAddressFilteredCount default = 0x0000;
    callback attribute rxDestAddrFilteredCount default = 0x0000;
    callback attribute rxDuplicatedCount default = 0x0000;
    callback attribute rxErrNoFrameCount default = 0x0000;
    callback attribute rxErrUnknownNeighborCount default = 0x0000;
    callback attribute rxErrInvalidSrcAddrCount default = 0x0000;
    callback attribute rxErrSecCount default = 0x0000;
    callback attribute rxErrFcsCount default = 0x0000;
    callback attribute rxErrOtherCount default = 0x0000;
    callback attribute activeTimestamp default = 0x0000000000000000;
    callback attribute pendingTimestamp default = 0x0000000000000000;
    callback attribute delay default = 0x0000;
    callback attribute securityPolicy;
    callback attribute channelPage0Mask default = "0x0000";
    callback attribute operationalDatasetComponents;
    callback attribute activeNetworkFaultsList;
    ram      attribute featureMap default = 0x000F;
    ram      attribute clusterRevision default = 1;

    handle command ResetCounts;
  }

  server cluster WiFiNetworkDiagnostics {
    emits event Disconnection;
    emits event AssociationFailure;
    emits event ConnectionStatus;
    callback attribute bssid;
    callback attribute securityType;
    callback attribute wiFiVersion;
    callback attribute channelNumber default = 0x0000;
    callback attribute rssi default = 0x00;
    callback attribute beaconLostCount default = 0x00000000;
    callback attribute beaconRxCount default = 0x00000000;
    callback attribute packetMulticastRxCount default = 0x00000000;
    callback attribute packetMulticastTxCount default = 0x00000000;
    callback attribute packetUnicastRxCount default = 0x00000000;
    callback attribute packetUnicastTxCount default = 0x00000000;
    callback attribute currentMaxRate default = 0x0000000000000000;
    callback attribute overrunCount default = 0x0000000000000000;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;

    handle command ResetCounts;
  }

  server cluster EthernetNetworkDiagnostics {
    callback attribute PHYRate;
    callback attribute fullDuplex default = 0x00;
    callback attribute packetRxCount default = 0x0000000000000000;
    callback attribute packetTxCount default = 0x0000000000000000;
    callback attribute txErrCount default = 0x0000000000000000;
    callback attribute collisionCount default = 0x0000000000000000;
    callback attribute overrunCount default = 0x0000000000000000;
    callback attribute carrierDetect default = 0x00;
    callback attribute timeSinceReset default = 0x0000000000000000;
    ram      attribute featureMap default = 3;
    ram      attribute clusterRevision default = 1;

    handle command ResetCounts;
  }

  server cluster Switch {
    ram      attribute numberOfPositions default = 2;
    ram      attribute currentPosition;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster AdministratorCommissioning {
    callback attribute windowStatus default = 0;
    callback attribute adminFabricIndex default = 1;
    callback attribute adminVendorId default = 0;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command OpenCommissioningWindow;
    handle command OpenBasicCommissioningWindow;
    handle command RevokeCommissioning;
  }

  server cluster OperationalCredentials {
    callback attribute NOCs;
    callback attribute fabrics;
    callback attribute supportedFabrics;
    callback attribute commissionedFabrics;
    callback attribute trustedRootCertificates;
    callback attribute currentFabricIndex;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command AttestationRequest;
    handle command AttestationResponse;
    handle command CertificateChainRequest;
    handle command CertificateChainResponse;
    handle command CSRRequest;
    handle command CSRResponse;
    handle command AddNOC;
    handle command UpdateNOC;
    handle command NOCResponse;
    handle command UpdateFabricLabel;
    handle command RemoveFabric;
    handle command AddTrustedRootCertificate;
  }

  server cluster GroupKeyManagement {
    callback attribute groupKeyMap;
    callback attribute groupTable;
    callback attribute maxGroupsPerFabric;
    callback attribute maxGroupKeysPerFabric;
    callback attribute featureMap default = 0;
    callback attribute clusterRevision default = 1;

    handle command KeySetWrite;
    handle command KeySetRead;
    handle command KeySetReadResponse;
    handle command KeySetRemove;
    handle command KeySetReadAllIndices;
    handle command KeySetReadAllIndicesResponse;
  }

  server cluster FixedLabel {
    callback attribute labelList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster UserLabel {
    callback attribute labelList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }
}
endpoint 1 {

  binding cluster LevelControl;
  binding cluster DoorLock;
  binding cluster BarrierControl;

  server cluster Identify {
    ram      attribute identifyTime default = 0x0;
    ram      attribute identifyType default = 0x00;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;

    handle command Identify;
    handle command TriggerEffect;
  }

  server cluster Groups {
    ram      attribute nameSupport;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 4;

    handle command AddGroup;
    handle command AddGroupResponse;
    handle command ViewGroup;
    handle command ViewGroupResponse;
    handle command GetGroupMembership;
    handle command GetGroupMembershipResponse;
    handle command RemoveGroup;
    handle command RemoveGroupResponse;
    handle command RemoveAllGroups;
    handle command AddGroupIfIdentifying;
  }

  server cluster LevelControl {
    ram      attribute currentLevel default = 0x00;
    ram      attribute options default = 0x00;
    ram      attribute onLevel;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 5;

    handle command MoveToLevel;
    handle command Move;
    handle command Step;
    handle command Stop;
    handle command MoveToLevelWithOnOff;
    handle command MoveWithOnOff;
    handle command StepWithOnOff;
    handle command StopWithOnOff;
  }

  server cluster Descriptor {
    callback attribute deviceTypeList;
    callback attribute serverList;
    callback attribute clientList;
    callback attribute partsList;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    callback attribute clusterRevision default = 2;
  }

  server cluster Binding {
    callback attribute binding;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster DeviceEnergyManagement {
    emits event PowerAdjustStart;
    emits event PowerAdjustEnd;
    emits event Paused;
    emits event Resumed;
    ram      attribute esaType default = 255;
    ram      attribute esaIsGenerator default = false;
    ram      attribute esaState default = 0;
    ram      attribute absMinPower default = 0;
    ram      attribute absMaxPower default = 0;
    callback attribute powerAdjustmentCapability;
    callback attribute forecast;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command PowerAdjustRequest;
    handle command CancelPowerAdjustRequest;
    handle command StartTimeAdjustRequest;
    handle command PauseRequest;
    handle command ResumeRequest;
    handle command ModifyForecastRequest;
    handle command RequestConstraintBasedForecast;
  }

  server cluster EnergyEvse {
    emits event EVConnected;
    emits event EVNotDetected;
    emits event EnergyTransferStarted;
    emits event EnergyTransferStopped;
    emits event Fault;
    emits event RFID;
    ram      attribute state;
    ram      attribute supplyState;
    ram      attribute faultState;
    ram      attribute enableChargeTime;
    ram      attribute enableDischargeTime;
    ram      attribute circuitCapacity default = 0x0;
    ram      attribute minimumChargeCurrent default = 0x1770;
    ram      attribute maximumChargeCurrent default = 0x0;
    ram      attribute maximumDischargeCurrent default = 0x0;
    ram      attribute userMaximumChargeCurrent default = 0x0;
    ram      attribute randomisationDelayWindow default = 600;
    ram      attribute numberOfWeeklyTargets default = 0x0;
    ram      attribute numberOfDailyTargets default = 0x1;
    ram      attribute nextChargeStartTime;
    ram      attribute nextChargeTargetTime;
    ram      attribute nextChargeRequiredEnergy;
    ram      attribute nextChargeTargetSoc;
    ram      attribute approxEvEfficiency;
    ram      attribute stateOfCharge;
    ram      attribute batteryCapacity;
    ram      attribute vehicleId;
    ram      attribute sessionId default = 0x0;
    ram      attribute eventSequenceNumber default = 0x0001;
    ram      attribute sessionDuration default = 0x0;
    ram      attribute sessionEnergyCharged default = 0x0;
    ram      attribute sessionEnergyDischarged default = 0x0;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command GetTargetsResponse;
    handle command Disable;
    handle command EnableCharging;
    handle command EnableDischarging;
    handle command StartDiagnostics;
    handle command SetTargets;
    handle command GetTargets;
    handle command ClearTargets;
  }

  server cluster DoorLock {
    ram      attribute lockState;
    ram      attribute lockType;
    ram      attribute actuatorEnabled;
    ram      attribute autoRelockTime;
    ram      attribute operatingMode;
    ram      attribute supportedOperatingModes default = 0xFFF6;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0x0001;
    ram      attribute clusterRevision default = 7;

    handle command LockDoor;
    handle command UnlockDoor;
    handle command SetUser;
    handle command GetUser;
    handle command GetUserResponse;
    handle command ClearUser;
    handle command SetCredential;
    handle command SetCredentialResponse;
    handle command ClearCredential;
  }

  server cluster BarrierControl {
    ram      attribute barrierMovingState;
    ram      attribute barrierSafetyStatus;
    ram      attribute barrierCapabilities;
    ram      attribute barrierPosition;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;

    handle command BarrierControlGoToPercent;
    handle command BarrierControlStop;
  }

  server cluster TemperatureMeasurement {
    ram      attribute measuredValue;
    ram      attribute minMeasuredValue default = 0x8000;
    ram      attribute maxMeasuredValue default = 0x8000;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ElectricalMeasurement {
    ram      attribute measurementType;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ElectricalPowerMeasurement {
    ram      attribute powerMode;
    callback attribute accuracy;
    callback attribute ranges;
    ram      attribute voltage;
    ram      attribute current;
    ram      attribute activePower;
    ram      attribute rmsCurrent;
    ram      attribute rmsPower;
    ram      attribute apparentPower;
    ram      attribute reactivePower;
    ram      attribute frequency;
    callback attribute harmonicCurrents;
    callback attribute harmonicPhases;
    ram      attribute powerFactor;
    ram      attribute lineCurrent;
    ram      attribute neutralCurrent;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }

  server cluster ElectricalEnergyMeasurement {
    ram      attribute measured;
    ram      attribute cumulativeEnergyImportedTime;
    ram      attribute cumulativeEnergyImported;
    ram      attribute cumulativeEnergyExportedTime;
    ram      attribute cumulativeEnergyExported;
    ram      attribute periodicEnergyImportedStartTime;
    ram      attribute periodicEnergyImportedEndTime;
    ram      attribute periodicEnergyImported;
    ram      attribute periodicEnergyExportedStartTime;
    ram      attribute periodicEnergyExportedEndTime;
    ram      attribute periodicEnergyExported;
    ram      attribute ephemeralEnergyImported;
    ram      attribute ephemeralEnergyExported;
    callback attribute generatedCommandList;
    callback attribute acceptedCommandList;
    callback attribute eventList;
    callback attribute attributeList;
    ram      attribute featureMap default = 0;
    ram      attribute clusterRevision default = 1;
  }
}


